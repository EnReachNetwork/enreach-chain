"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.ModeInfo = exports.SignerInfo = exports.GetBlockWithTxsRequest = exports.AuthInfo = exports.SignDoc = exports.TxDecodeRequest = exports.ModeInfo_Multi = exports.TxEncodeAminoResponse = exports.GetTxResponse = exports.BroadcastTxResponse = exports.TxDecodeAminoRequest = exports.GetTxRequest = exports.SimulateResponse = exports.AuxSignerData = exports.GetTxsEventRequest = exports.Fee = exports.TxDecodeResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.SimulateRequest = exports.SignDocDirectAux = exports.Tx = exports.TxDecodeAminoResponse = exports.TxEncodeAminoRequest = exports.GetBlockWithTxsResponse = exports.ModeInfo_Single = exports.TxBody = exports.TxRaw = exports.TxEncodeResponse = exports.TxEncodeRequest = exports.Tip = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const tx_1 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "Tip", { enumerable: true, get: function () { return tx_1.Tip; } });
const service_1 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxEncodeRequest", { enumerable: true, get: function () { return service_1.TxEncodeRequest; } });
const service_2 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxEncodeResponse", { enumerable: true, get: function () { return service_2.TxEncodeResponse; } });
const tx_2 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "TxRaw", { enumerable: true, get: function () { return tx_2.TxRaw; } });
const tx_3 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "TxBody", { enumerable: true, get: function () { return tx_3.TxBody; } });
const tx_4 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "ModeInfo_Single", { enumerable: true, get: function () { return tx_4.ModeInfo_Single; } });
const service_3 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetBlockWithTxsResponse", { enumerable: true, get: function () { return service_3.GetBlockWithTxsResponse; } });
const service_4 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxEncodeAminoRequest", { enumerable: true, get: function () { return service_4.TxEncodeAminoRequest; } });
const service_5 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxDecodeAminoResponse", { enumerable: true, get: function () { return service_5.TxDecodeAminoResponse; } });
const tx_5 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "Tx", { enumerable: true, get: function () { return tx_5.Tx; } });
const tx_6 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "SignDocDirectAux", { enumerable: true, get: function () { return tx_6.SignDocDirectAux; } });
const service_6 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "SimulateRequest", { enumerable: true, get: function () { return service_6.SimulateRequest; } });
const service_7 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetTxsEventResponse", { enumerable: true, get: function () { return service_7.GetTxsEventResponse; } });
const service_8 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "BroadcastTxRequest", { enumerable: true, get: function () { return service_8.BroadcastTxRequest; } });
const service_9 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxDecodeResponse", { enumerable: true, get: function () { return service_9.TxDecodeResponse; } });
const tx_7 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "Fee", { enumerable: true, get: function () { return tx_7.Fee; } });
const service_10 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetTxsEventRequest", { enumerable: true, get: function () { return service_10.GetTxsEventRequest; } });
const tx_8 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "AuxSignerData", { enumerable: true, get: function () { return tx_8.AuxSignerData; } });
const service_11 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "SimulateResponse", { enumerable: true, get: function () { return service_11.SimulateResponse; } });
const service_12 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetTxRequest", { enumerable: true, get: function () { return service_12.GetTxRequest; } });
const service_13 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxDecodeAminoRequest", { enumerable: true, get: function () { return service_13.TxDecodeAminoRequest; } });
const service_14 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "BroadcastTxResponse", { enumerable: true, get: function () { return service_14.BroadcastTxResponse; } });
const service_15 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetTxResponse", { enumerable: true, get: function () { return service_15.GetTxResponse; } });
const service_16 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxEncodeAminoResponse", { enumerable: true, get: function () { return service_16.TxEncodeAminoResponse; } });
const tx_9 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "ModeInfo_Multi", { enumerable: true, get: function () { return tx_9.ModeInfo_Multi; } });
const service_17 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "TxDecodeRequest", { enumerable: true, get: function () { return service_17.TxDecodeRequest; } });
const tx_10 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "SignDoc", { enumerable: true, get: function () { return tx_10.SignDoc; } });
const tx_11 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "AuthInfo", { enumerable: true, get: function () { return tx_11.AuthInfo; } });
const service_18 = require("./types/cosmos/tx/v1beta1/service");
Object.defineProperty(exports, "GetBlockWithTxsRequest", { enumerable: true, get: function () { return service_18.GetBlockWithTxsRequest; } });
const tx_12 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "SignerInfo", { enumerable: true, get: function () { return tx_12.SignerInfo; } });
const tx_13 = require("./types/cosmos/tx/v1beta1/tx");
Object.defineProperty(exports, "ModeInfo", { enumerable: true, get: function () { return tx_13.ModeInfo; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendTip({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTip: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.tip({ value: tx_1.Tip.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTip: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxEncodeRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxEncodeRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txEncodeRequest({ value: service_1.TxEncodeRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxEncodeRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxEncodeResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxEncodeResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txEncodeResponse({ value: service_2.TxEncodeResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxEncodeResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxRaw({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxRaw: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txRaw({ value: tx_2.TxRaw.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxRaw: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxBody({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxBody: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txBody({ value: tx_3.TxBody.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxBody: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModeInfo_Single({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModeInfo_Single: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.modeInfoSingle({ value: tx_4.ModeInfo_Single.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModeInfo_Single: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetBlockWithTxsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetBlockWithTxsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getBlockWithTxsResponse({ value: service_3.GetBlockWithTxsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetBlockWithTxsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxEncodeAminoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxEncodeAminoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txEncodeAminoRequest({ value: service_4.TxEncodeAminoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxEncodeAminoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxDecodeAminoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxDecodeAminoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txDecodeAminoResponse({ value: service_5.TxDecodeAminoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxDecodeAminoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTx({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTx: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.tx({ value: tx_5.Tx.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTx: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSignDocDirectAux({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSignDocDirectAux: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.signDocDirectAux({ value: tx_6.SignDocDirectAux.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSignDocDirectAux: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSimulateRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSimulateRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.simulateRequest({ value: service_6.SimulateRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSimulateRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetTxsEventResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetTxsEventResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getTxsEventResponse({ value: service_7.GetTxsEventResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetTxsEventResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBroadcastTxRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBroadcastTxRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.broadcastTxRequest({ value: service_8.BroadcastTxRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBroadcastTxRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxDecodeResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxDecodeResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txDecodeResponse({ value: service_9.TxDecodeResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxDecodeResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendFee({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendFee: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.fee({ value: tx_7.Fee.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendFee: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetTxsEventRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetTxsEventRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getTxsEventRequest({ value: service_10.GetTxsEventRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetTxsEventRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAuxSignerData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAuxSignerData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.auxSignerData({ value: tx_8.AuxSignerData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAuxSignerData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSimulateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSimulateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.simulateResponse({ value: service_11.SimulateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSimulateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetTxRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetTxRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getTxRequest({ value: service_12.GetTxRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetTxRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxDecodeAminoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxDecodeAminoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txDecodeAminoRequest({ value: service_13.TxDecodeAminoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxDecodeAminoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBroadcastTxResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBroadcastTxResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.broadcastTxResponse({ value: service_14.BroadcastTxResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBroadcastTxResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetTxResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetTxResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getTxResponse({ value: service_15.GetTxResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetTxResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxEncodeAminoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxEncodeAminoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txEncodeAminoResponse({ value: service_16.TxEncodeAminoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxEncodeAminoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModeInfo_Multi({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModeInfo_Multi: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.modeInfoMulti({ value: tx_9.ModeInfo_Multi.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModeInfo_Multi: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendTxDecodeRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTxDecodeRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.txDecodeRequest({ value: service_17.TxDecodeRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTxDecodeRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSignDoc({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSignDoc: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.signDoc({ value: tx_10.SignDoc.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSignDoc: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAuthInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAuthInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.authInfo({ value: tx_11.AuthInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAuthInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetBlockWithTxsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetBlockWithTxsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getBlockWithTxsRequest({ value: service_18.GetBlockWithTxsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetBlockWithTxsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSignerInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSignerInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.signerInfo({ value: tx_12.SignerInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSignerInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModeInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModeInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.modeInfo({ value: tx_13.ModeInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModeInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        tip({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.Tip", value: tx_1.Tip.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Tip: Could not create message: ' + e.message);
            }
        },
        txEncodeRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest", value: service_1.TxEncodeRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxEncodeRequest: Could not create message: ' + e.message);
            }
        },
        txEncodeResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse", value: service_2.TxEncodeResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxEncodeResponse: Could not create message: ' + e.message);
            }
        },
        txRaw({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxRaw", value: tx_2.TxRaw.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxRaw: Could not create message: ' + e.message);
            }
        },
        txBody({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxBody", value: tx_3.TxBody.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxBody: Could not create message: ' + e.message);
            }
        },
        modeInfoSingle({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.ModeInfo_Single", value: tx_4.ModeInfo_Single.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ModeInfo_Single: Could not create message: ' + e.message);
            }
        },
        getBlockWithTxsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse", value: service_3.GetBlockWithTxsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetBlockWithTxsResponse: Could not create message: ' + e.message);
            }
        },
        txEncodeAminoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest", value: service_4.TxEncodeAminoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxEncodeAminoRequest: Could not create message: ' + e.message);
            }
        },
        txDecodeAminoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse", value: service_5.TxDecodeAminoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxDecodeAminoResponse: Could not create message: ' + e.message);
            }
        },
        tx({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.Tx", value: tx_5.Tx.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Tx: Could not create message: ' + e.message);
            }
        },
        signDocDirectAux({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux", value: tx_6.SignDocDirectAux.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SignDocDirectAux: Could not create message: ' + e.message);
            }
        },
        simulateRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.SimulateRequest", value: service_6.SimulateRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SimulateRequest: Could not create message: ' + e.message);
            }
        },
        getTxsEventResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse", value: service_7.GetTxsEventResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetTxsEventResponse: Could not create message: ' + e.message);
            }
        },
        broadcastTxRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest", value: service_8.BroadcastTxRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BroadcastTxRequest: Could not create message: ' + e.message);
            }
        },
        txDecodeResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse", value: service_9.TxDecodeResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxDecodeResponse: Could not create message: ' + e.message);
            }
        },
        fee({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.Fee", value: tx_7.Fee.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Fee: Could not create message: ' + e.message);
            }
        },
        getTxsEventRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest", value: service_10.GetTxsEventRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetTxsEventRequest: Could not create message: ' + e.message);
            }
        },
        auxSignerData({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.AuxSignerData", value: tx_8.AuxSignerData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AuxSignerData: Could not create message: ' + e.message);
            }
        },
        simulateResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.SimulateResponse", value: service_11.SimulateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SimulateResponse: Could not create message: ' + e.message);
            }
        },
        getTxRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetTxRequest", value: service_12.GetTxRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetTxRequest: Could not create message: ' + e.message);
            }
        },
        txDecodeAminoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest", value: service_13.TxDecodeAminoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxDecodeAminoRequest: Could not create message: ' + e.message);
            }
        },
        broadcastTxResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse", value: service_14.BroadcastTxResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BroadcastTxResponse: Could not create message: ' + e.message);
            }
        },
        getTxResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetTxResponse", value: service_15.GetTxResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetTxResponse: Could not create message: ' + e.message);
            }
        },
        txEncodeAminoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse", value: service_16.TxEncodeAminoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxEncodeAminoResponse: Could not create message: ' + e.message);
            }
        },
        modeInfoMulti({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.ModeInfo_Multi", value: tx_9.ModeInfo_Multi.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ModeInfo_Multi: Could not create message: ' + e.message);
            }
        },
        txDecodeRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest", value: service_17.TxDecodeRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:TxDecodeRequest: Could not create message: ' + e.message);
            }
        },
        signDoc({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.SignDoc", value: tx_10.SignDoc.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SignDoc: Could not create message: ' + e.message);
            }
        },
        authInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.AuthInfo", value: tx_11.AuthInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AuthInfo: Could not create message: ' + e.message);
            }
        },
        getBlockWithTxsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest", value: service_18.GetBlockWithTxsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetBlockWithTxsRequest: Could not create message: ' + e.message);
            }
        },
        signerInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.SignerInfo", value: tx_12.SignerInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SignerInfo: Could not create message: ' + e.message);
            }
        },
        modeInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.tx.v1beta1.ModeInfo", value: tx_13.ModeInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ModeInfo: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosTxV1Beta1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
