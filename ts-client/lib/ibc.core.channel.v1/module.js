"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryUpgradeRequest = exports.MsgChannelOpenTry = exports.QueryChannelConsensusStateRequest = exports.QueryChannelClientStateRequest = exports.PacketId = exports.MsgChannelUpgradeTry = exports.MsgChannelUpgradeInit = exports.Acknowledgement = exports.QueryUnreceivedAcksRequest = exports.QueryPacketCommitmentResponse = exports.QueryChannelConsensusStateResponse = exports.QueryChannelClientStateResponse = exports.MsgUpdateParams = exports.MsgChannelUpgradeTimeoutResponse = exports.MsgChannelUpgradeConfirmResponse = exports.MsgChannelOpenInitResponse = exports.QueryNextSequenceReceiveResponse = exports.PacketState = exports.Packet = exports.MsgRecvPacket = exports.MsgChannelOpenAck = exports.GenesisState = exports.QueryUnreceivedAcksResponse = exports.QueryPacketReceiptResponse = exports.QueryChannelsRequest = exports.QueryUpgradeResponse = exports.QueryChannelResponse = exports.MsgChannelOpenInit = exports.MsgChannelUpgradeCancel = exports.MsgAcknowledgement = exports.PacketSequence = exports.Upgrade = exports.MsgAcknowledgementResponse = exports.MsgChannelOpenAckResponse = exports.Params = exports.QueryNextSequenceReceiveRequest = exports.QueryPacketAcknowledgementsResponse = exports.QueryPacketAcknowledgementRequest = exports.MsgChannelCloseConfirmResponse = exports.MsgUpdateParamsResponse = exports.MsgChannelUpgradeOpenResponse = exports.MsgChannelCloseInitResponse = exports.QueryPacketAcknowledgementsRequest = exports.MsgTimeoutOnClose = exports.QueryNextSequenceSendResponse = exports.QueryUnreceivedPacketsResponse = exports.MsgPruneAcknowledgements = exports.MsgChannelUpgradeAck = exports.ErrorReceipt = exports.Timeout = void 0;
exports.queryClient = exports.txClient = exports.registry = exports.MsgTimeoutOnCloseResponse = exports.MsgRecvPacketResponse = exports.QueryChannelParamsResponse = exports.QueryUnreceivedPacketsRequest = exports.QueryPacketCommitmentsRequest = exports.MsgChannelUpgradeAckResponse = exports.IdentifiedChannel = exports.QueryUpgradeErrorRequest = exports.QueryConnectionChannelsResponse = exports.QueryConnectionChannelsRequest = exports.MsgTimeout = exports.MsgChannelCloseConfirm = exports.MsgChannelOpenConfirmResponse = exports.QueryUpgradeErrorResponse = exports.MsgChannelUpgradeTryResponse = exports.MsgTimeoutResponse = exports.QueryPacketCommitmentsResponse = exports.QueryChannelsResponse = exports.MsgChannelCloseInit = exports.MsgChannelUpgradeTimeout = exports.MsgChannelUpgradeConfirm = exports.MsgChannelUpgradeInitResponse = exports.QueryNextSequenceSendRequest = exports.QueryPacketCommitmentRequest = exports.Channel = exports.MsgChannelOpenConfirm = exports.MsgPruneAcknowledgementsResponse = exports.MsgChannelUpgradeCancelResponse = exports.QueryPacketReceiptRequest = exports.QueryChannelRequest = exports.Counterparty = exports.MsgChannelUpgradeOpen = exports.UpgradeFields = exports.MsgChannelOpenTryResponse = exports.QueryChannelParamsRequest = exports.QueryPacketAcknowledgementResponse = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const channel_1 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Timeout", { enumerable: true, get: function () { return channel_1.Timeout; } });
const upgrade_1 = require("./types/ibc/core/channel/v1/upgrade");
Object.defineProperty(exports, "ErrorReceipt", { enumerable: true, get: function () { return upgrade_1.ErrorReceipt; } });
const tx_1 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeAck", { enumerable: true, get: function () { return tx_1.MsgChannelUpgradeAck; } });
const tx_2 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgPruneAcknowledgements", { enumerable: true, get: function () { return tx_2.MsgPruneAcknowledgements; } });
const query_1 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUnreceivedPacketsResponse", { enumerable: true, get: function () { return query_1.QueryUnreceivedPacketsResponse; } });
const query_2 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryNextSequenceSendResponse", { enumerable: true, get: function () { return query_2.QueryNextSequenceSendResponse; } });
const tx_3 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgTimeoutOnClose", { enumerable: true, get: function () { return tx_3.MsgTimeoutOnClose; } });
const query_3 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketAcknowledgementsRequest", { enumerable: true, get: function () { return query_3.QueryPacketAcknowledgementsRequest; } });
const tx_4 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelCloseInitResponse", { enumerable: true, get: function () { return tx_4.MsgChannelCloseInitResponse; } });
const tx_5 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeOpenResponse", { enumerable: true, get: function () { return tx_5.MsgChannelUpgradeOpenResponse; } });
const tx_6 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgUpdateParamsResponse", { enumerable: true, get: function () { return tx_6.MsgUpdateParamsResponse; } });
const tx_7 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelCloseConfirmResponse", { enumerable: true, get: function () { return tx_7.MsgChannelCloseConfirmResponse; } });
const query_4 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketAcknowledgementRequest", { enumerable: true, get: function () { return query_4.QueryPacketAcknowledgementRequest; } });
const query_5 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketAcknowledgementsResponse", { enumerable: true, get: function () { return query_5.QueryPacketAcknowledgementsResponse; } });
const query_6 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryNextSequenceReceiveRequest", { enumerable: true, get: function () { return query_6.QueryNextSequenceReceiveRequest; } });
const channel_2 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Params", { enumerable: true, get: function () { return channel_2.Params; } });
const tx_8 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenAckResponse", { enumerable: true, get: function () { return tx_8.MsgChannelOpenAckResponse; } });
const tx_9 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgAcknowledgementResponse", { enumerable: true, get: function () { return tx_9.MsgAcknowledgementResponse; } });
const upgrade_2 = require("./types/ibc/core/channel/v1/upgrade");
Object.defineProperty(exports, "Upgrade", { enumerable: true, get: function () { return upgrade_2.Upgrade; } });
const genesis_1 = require("./types/ibc/core/channel/v1/genesis");
Object.defineProperty(exports, "PacketSequence", { enumerable: true, get: function () { return genesis_1.PacketSequence; } });
const tx_10 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgAcknowledgement", { enumerable: true, get: function () { return tx_10.MsgAcknowledgement; } });
const tx_11 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeCancel", { enumerable: true, get: function () { return tx_11.MsgChannelUpgradeCancel; } });
const tx_12 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenInit", { enumerable: true, get: function () { return tx_12.MsgChannelOpenInit; } });
const query_7 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelResponse", { enumerable: true, get: function () { return query_7.QueryChannelResponse; } });
const query_8 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUpgradeResponse", { enumerable: true, get: function () { return query_8.QueryUpgradeResponse; } });
const query_9 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelsRequest", { enumerable: true, get: function () { return query_9.QueryChannelsRequest; } });
const query_10 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketReceiptResponse", { enumerable: true, get: function () { return query_10.QueryPacketReceiptResponse; } });
const query_11 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUnreceivedAcksResponse", { enumerable: true, get: function () { return query_11.QueryUnreceivedAcksResponse; } });
const genesis_2 = require("./types/ibc/core/channel/v1/genesis");
Object.defineProperty(exports, "GenesisState", { enumerable: true, get: function () { return genesis_2.GenesisState; } });
const tx_13 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenAck", { enumerable: true, get: function () { return tx_13.MsgChannelOpenAck; } });
const tx_14 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgRecvPacket", { enumerable: true, get: function () { return tx_14.MsgRecvPacket; } });
const channel_3 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Packet", { enumerable: true, get: function () { return channel_3.Packet; } });
const channel_4 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "PacketState", { enumerable: true, get: function () { return channel_4.PacketState; } });
const query_12 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryNextSequenceReceiveResponse", { enumerable: true, get: function () { return query_12.QueryNextSequenceReceiveResponse; } });
const tx_15 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenInitResponse", { enumerable: true, get: function () { return tx_15.MsgChannelOpenInitResponse; } });
const tx_16 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeConfirmResponse", { enumerable: true, get: function () { return tx_16.MsgChannelUpgradeConfirmResponse; } });
const tx_17 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeTimeoutResponse", { enumerable: true, get: function () { return tx_17.MsgChannelUpgradeTimeoutResponse; } });
const tx_18 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgUpdateParams", { enumerable: true, get: function () { return tx_18.MsgUpdateParams; } });
const query_13 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelClientStateResponse", { enumerable: true, get: function () { return query_13.QueryChannelClientStateResponse; } });
const query_14 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelConsensusStateResponse", { enumerable: true, get: function () { return query_14.QueryChannelConsensusStateResponse; } });
const query_15 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketCommitmentResponse", { enumerable: true, get: function () { return query_15.QueryPacketCommitmentResponse; } });
const query_16 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUnreceivedAcksRequest", { enumerable: true, get: function () { return query_16.QueryUnreceivedAcksRequest; } });
const channel_5 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Acknowledgement", { enumerable: true, get: function () { return channel_5.Acknowledgement; } });
const tx_19 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeInit", { enumerable: true, get: function () { return tx_19.MsgChannelUpgradeInit; } });
const tx_20 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeTry", { enumerable: true, get: function () { return tx_20.MsgChannelUpgradeTry; } });
const channel_6 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "PacketId", { enumerable: true, get: function () { return channel_6.PacketId; } });
const query_17 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelClientStateRequest", { enumerable: true, get: function () { return query_17.QueryChannelClientStateRequest; } });
const query_18 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelConsensusStateRequest", { enumerable: true, get: function () { return query_18.QueryChannelConsensusStateRequest; } });
const tx_21 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenTry", { enumerable: true, get: function () { return tx_21.MsgChannelOpenTry; } });
const query_19 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUpgradeRequest", { enumerable: true, get: function () { return query_19.QueryUpgradeRequest; } });
const query_20 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketAcknowledgementResponse", { enumerable: true, get: function () { return query_20.QueryPacketAcknowledgementResponse; } });
const query_21 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelParamsRequest", { enumerable: true, get: function () { return query_21.QueryChannelParamsRequest; } });
const tx_22 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenTryResponse", { enumerable: true, get: function () { return tx_22.MsgChannelOpenTryResponse; } });
const upgrade_3 = require("./types/ibc/core/channel/v1/upgrade");
Object.defineProperty(exports, "UpgradeFields", { enumerable: true, get: function () { return upgrade_3.UpgradeFields; } });
const tx_23 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeOpen", { enumerable: true, get: function () { return tx_23.MsgChannelUpgradeOpen; } });
const channel_7 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Counterparty", { enumerable: true, get: function () { return channel_7.Counterparty; } });
const query_22 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelRequest", { enumerable: true, get: function () { return query_22.QueryChannelRequest; } });
const query_23 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketReceiptRequest", { enumerable: true, get: function () { return query_23.QueryPacketReceiptRequest; } });
const tx_24 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeCancelResponse", { enumerable: true, get: function () { return tx_24.MsgChannelUpgradeCancelResponse; } });
const tx_25 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgPruneAcknowledgementsResponse", { enumerable: true, get: function () { return tx_25.MsgPruneAcknowledgementsResponse; } });
const tx_26 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenConfirm", { enumerable: true, get: function () { return tx_26.MsgChannelOpenConfirm; } });
const channel_8 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return channel_8.Channel; } });
const query_24 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketCommitmentRequest", { enumerable: true, get: function () { return query_24.QueryPacketCommitmentRequest; } });
const query_25 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryNextSequenceSendRequest", { enumerable: true, get: function () { return query_25.QueryNextSequenceSendRequest; } });
const tx_27 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeInitResponse", { enumerable: true, get: function () { return tx_27.MsgChannelUpgradeInitResponse; } });
const tx_28 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeConfirm", { enumerable: true, get: function () { return tx_28.MsgChannelUpgradeConfirm; } });
const tx_29 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeTimeout", { enumerable: true, get: function () { return tx_29.MsgChannelUpgradeTimeout; } });
const tx_30 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelCloseInit", { enumerable: true, get: function () { return tx_30.MsgChannelCloseInit; } });
const query_26 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelsResponse", { enumerable: true, get: function () { return query_26.QueryChannelsResponse; } });
const query_27 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketCommitmentsResponse", { enumerable: true, get: function () { return query_27.QueryPacketCommitmentsResponse; } });
const tx_31 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgTimeoutResponse", { enumerable: true, get: function () { return tx_31.MsgTimeoutResponse; } });
const tx_32 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeTryResponse", { enumerable: true, get: function () { return tx_32.MsgChannelUpgradeTryResponse; } });
const query_28 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUpgradeErrorResponse", { enumerable: true, get: function () { return query_28.QueryUpgradeErrorResponse; } });
const tx_33 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelOpenConfirmResponse", { enumerable: true, get: function () { return tx_33.MsgChannelOpenConfirmResponse; } });
const tx_34 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelCloseConfirm", { enumerable: true, get: function () { return tx_34.MsgChannelCloseConfirm; } });
const tx_35 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgTimeout", { enumerable: true, get: function () { return tx_35.MsgTimeout; } });
const query_29 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryConnectionChannelsRequest", { enumerable: true, get: function () { return query_29.QueryConnectionChannelsRequest; } });
const query_30 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryConnectionChannelsResponse", { enumerable: true, get: function () { return query_30.QueryConnectionChannelsResponse; } });
const query_31 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUpgradeErrorRequest", { enumerable: true, get: function () { return query_31.QueryUpgradeErrorRequest; } });
const channel_9 = require("./types/ibc/core/channel/v1/channel");
Object.defineProperty(exports, "IdentifiedChannel", { enumerable: true, get: function () { return channel_9.IdentifiedChannel; } });
const tx_36 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgChannelUpgradeAckResponse", { enumerable: true, get: function () { return tx_36.MsgChannelUpgradeAckResponse; } });
const query_32 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryPacketCommitmentsRequest", { enumerable: true, get: function () { return query_32.QueryPacketCommitmentsRequest; } });
const query_33 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryUnreceivedPacketsRequest", { enumerable: true, get: function () { return query_33.QueryUnreceivedPacketsRequest; } });
const query_34 = require("./types/ibc/core/channel/v1/query");
Object.defineProperty(exports, "QueryChannelParamsResponse", { enumerable: true, get: function () { return query_34.QueryChannelParamsResponse; } });
const tx_37 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgRecvPacketResponse", { enumerable: true, get: function () { return tx_37.MsgRecvPacketResponse; } });
const tx_38 = require("./types/ibc/core/channel/v1/tx");
Object.defineProperty(exports, "MsgTimeoutOnCloseResponse", { enumerable: true, get: function () { return tx_38.MsgTimeoutOnCloseResponse; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendTimeout({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendTimeout: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.timeout({ value: channel_1.Timeout.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendTimeout: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendErrorReceipt({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendErrorReceipt: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.errorReceipt({ value: upgrade_1.ErrorReceipt.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendErrorReceipt: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeAck({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeAck: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeAck({ value: tx_1.MsgChannelUpgradeAck.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeAck: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgPruneAcknowledgements({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgPruneAcknowledgements: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgPruneAcknowledgements({ value: tx_2.MsgPruneAcknowledgements.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgPruneAcknowledgements: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnreceivedPacketsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnreceivedPacketsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnreceivedPacketsResponse({ value: query_1.QueryUnreceivedPacketsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnreceivedPacketsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryNextSequenceSendResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryNextSequenceSendResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryNextSequenceSendResponse({ value: query_2.QueryNextSequenceSendResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryNextSequenceSendResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTimeoutOnClose({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTimeoutOnClose: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgTimeoutOnClose({ value: tx_3.MsgTimeoutOnClose.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTimeoutOnClose: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketAcknowledgementsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketAcknowledgementsRequest({ value: query_3.QueryPacketAcknowledgementsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelCloseInitResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelCloseInitResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelCloseInitResponse({ value: tx_4.MsgChannelCloseInitResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelCloseInitResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeOpenResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeOpenResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeOpenResponse({ value: tx_5.MsgChannelUpgradeOpenResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeOpenResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParamsResponse({ value: tx_6.MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelCloseConfirmResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelCloseConfirmResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelCloseConfirmResponse({ value: tx_7.MsgChannelCloseConfirmResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelCloseConfirmResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketAcknowledgementRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketAcknowledgementRequest({ value: query_4.QueryPacketAcknowledgementRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketAcknowledgementsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketAcknowledgementsResponse({ value: query_5.QueryPacketAcknowledgementsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryNextSequenceReceiveRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryNextSequenceReceiveRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryNextSequenceReceiveRequest({ value: query_6.QueryNextSequenceReceiveRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryNextSequenceReceiveRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.params({ value: channel_2.Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenAckResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenAckResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenAckResponse({ value: tx_8.MsgChannelOpenAckResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenAckResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAcknowledgementResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAcknowledgementResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgAcknowledgementResponse({ value: tx_9.MsgAcknowledgementResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAcknowledgementResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendUpgrade({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendUpgrade: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.upgrade({ value: upgrade_2.Upgrade.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendUpgrade: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendPacketSequence({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendPacketSequence: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.packetSequence({ value: genesis_1.PacketSequence.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendPacketSequence: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAcknowledgement({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAcknowledgement: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgAcknowledgement({ value: tx_10.MsgAcknowledgement.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAcknowledgement: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeCancel({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeCancel: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeCancel({ value: tx_11.MsgChannelUpgradeCancel.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeCancel: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenInit({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenInit: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenInit({ value: tx_12.MsgChannelOpenInit.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenInit: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelResponse({ value: query_7.QueryChannelResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUpgradeResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUpgradeResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUpgradeResponse({ value: query_8.QueryUpgradeResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUpgradeResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelsRequest({ value: query_9.QueryChannelsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketReceiptResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketReceiptResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketReceiptResponse({ value: query_10.QueryPacketReceiptResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketReceiptResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnreceivedAcksResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnreceivedAcksResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnreceivedAcksResponse({ value: query_11.QueryUnreceivedAcksResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnreceivedAcksResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.genesisState({ value: genesis_2.GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenAck({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenAck: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenAck({ value: tx_13.MsgChannelOpenAck.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenAck: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRecvPacket({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRecvPacket: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgRecvPacket({ value: tx_14.MsgRecvPacket.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRecvPacket: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendPacket({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendPacket: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.packet({ value: channel_3.Packet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendPacket: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendPacketState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendPacketState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.packetState({ value: channel_4.PacketState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendPacketState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryNextSequenceReceiveResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryNextSequenceReceiveResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryNextSequenceReceiveResponse({ value: query_12.QueryNextSequenceReceiveResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryNextSequenceReceiveResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenInitResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenInitResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenInitResponse({ value: tx_15.MsgChannelOpenInitResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenInitResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeConfirmResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeConfirmResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeConfirmResponse({ value: tx_16.MsgChannelUpgradeConfirmResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeConfirmResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeTimeoutResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeTimeoutResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeTimeoutResponse({ value: tx_17.MsgChannelUpgradeTimeoutResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeTimeoutResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParams({ value: tx_18.MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelClientStateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelClientStateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelClientStateResponse({ value: query_13.QueryChannelClientStateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelClientStateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelConsensusStateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelConsensusStateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelConsensusStateResponse({ value: query_14.QueryChannelConsensusStateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelConsensusStateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketCommitmentResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketCommitmentResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketCommitmentResponse({ value: query_15.QueryPacketCommitmentResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketCommitmentResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnreceivedAcksRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnreceivedAcksRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnreceivedAcksRequest({ value: query_16.QueryUnreceivedAcksRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnreceivedAcksRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAcknowledgement({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAcknowledgement: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.acknowledgement({ value: channel_5.Acknowledgement.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAcknowledgement: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeInit({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeInit: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeInit({ value: tx_19.MsgChannelUpgradeInit.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeInit: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeTry({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeTry: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeTry({ value: tx_20.MsgChannelUpgradeTry.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeTry: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendPacketId({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendPacketId: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.packetId({ value: channel_6.PacketId.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendPacketId: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelClientStateRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelClientStateRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelClientStateRequest({ value: query_17.QueryChannelClientStateRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelClientStateRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelConsensusStateRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelConsensusStateRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelConsensusStateRequest({ value: query_18.QueryChannelConsensusStateRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelConsensusStateRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenTry({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenTry: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenTry({ value: tx_21.MsgChannelOpenTry.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenTry: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUpgradeRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUpgradeRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUpgradeRequest({ value: query_19.QueryUpgradeRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUpgradeRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketAcknowledgementResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketAcknowledgementResponse({ value: query_20.QueryPacketAcknowledgementResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketAcknowledgementResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelParamsRequest({ value: query_21.QueryChannelParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenTryResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenTryResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenTryResponse({ value: tx_22.MsgChannelOpenTryResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenTryResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendUpgradeFields({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendUpgradeFields: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.upgradeFields({ value: upgrade_3.UpgradeFields.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendUpgradeFields: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeOpen({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeOpen: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeOpen({ value: tx_23.MsgChannelUpgradeOpen.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeOpen: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCounterparty({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCounterparty: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.counterparty({ value: channel_7.Counterparty.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCounterparty: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelRequest({ value: query_22.QueryChannelRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketReceiptRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketReceiptRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketReceiptRequest({ value: query_23.QueryPacketReceiptRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketReceiptRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeCancelResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeCancelResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeCancelResponse({ value: tx_24.MsgChannelUpgradeCancelResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeCancelResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgPruneAcknowledgementsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgPruneAcknowledgementsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgPruneAcknowledgementsResponse({ value: tx_25.MsgPruneAcknowledgementsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgPruneAcknowledgementsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenConfirm({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenConfirm: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenConfirm({ value: tx_26.MsgChannelOpenConfirm.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenConfirm: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendChannel({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendChannel: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.channel({ value: channel_8.Channel.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendChannel: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketCommitmentRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketCommitmentRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketCommitmentRequest({ value: query_24.QueryPacketCommitmentRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketCommitmentRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryNextSequenceSendRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryNextSequenceSendRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryNextSequenceSendRequest({ value: query_25.QueryNextSequenceSendRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryNextSequenceSendRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeInitResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeInitResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeInitResponse({ value: tx_27.MsgChannelUpgradeInitResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeInitResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeConfirm({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeConfirm: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeConfirm({ value: tx_28.MsgChannelUpgradeConfirm.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeConfirm: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeTimeout({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeTimeout: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeTimeout({ value: tx_29.MsgChannelUpgradeTimeout.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeTimeout: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelCloseInit({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelCloseInit: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelCloseInit({ value: tx_30.MsgChannelCloseInit.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelCloseInit: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelsResponse({ value: query_26.QueryChannelsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketCommitmentsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketCommitmentsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketCommitmentsResponse({ value: query_27.QueryPacketCommitmentsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketCommitmentsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTimeoutResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTimeoutResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgTimeoutResponse({ value: tx_31.MsgTimeoutResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTimeoutResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeTryResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeTryResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeTryResponse({ value: tx_32.MsgChannelUpgradeTryResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeTryResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUpgradeErrorResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUpgradeErrorResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUpgradeErrorResponse({ value: query_28.QueryUpgradeErrorResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUpgradeErrorResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelOpenConfirmResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelOpenConfirmResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelOpenConfirmResponse({ value: tx_33.MsgChannelOpenConfirmResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelOpenConfirmResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelCloseConfirm({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelCloseConfirm: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelCloseConfirm({ value: tx_34.MsgChannelCloseConfirm.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelCloseConfirm: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTimeout({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTimeout: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgTimeout({ value: tx_35.MsgTimeout.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTimeout: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryConnectionChannelsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryConnectionChannelsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryConnectionChannelsRequest({ value: query_29.QueryConnectionChannelsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryConnectionChannelsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryConnectionChannelsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryConnectionChannelsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryConnectionChannelsResponse({ value: query_30.QueryConnectionChannelsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryConnectionChannelsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUpgradeErrorRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUpgradeErrorRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUpgradeErrorRequest({ value: query_31.QueryUpgradeErrorRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUpgradeErrorRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendIdentifiedChannel({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendIdentifiedChannel: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.identifiedChannel({ value: channel_9.IdentifiedChannel.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendIdentifiedChannel: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChannelUpgradeAckResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChannelUpgradeAckResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgChannelUpgradeAckResponse({ value: tx_36.MsgChannelUpgradeAckResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChannelUpgradeAckResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPacketCommitmentsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPacketCommitmentsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPacketCommitmentsRequest({ value: query_32.QueryPacketCommitmentsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPacketCommitmentsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnreceivedPacketsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnreceivedPacketsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnreceivedPacketsRequest({ value: query_33.QueryUnreceivedPacketsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnreceivedPacketsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryChannelParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryChannelParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryChannelParamsResponse({ value: query_34.QueryChannelParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryChannelParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRecvPacketResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRecvPacketResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgRecvPacketResponse({ value: tx_37.MsgRecvPacketResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRecvPacketResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTimeoutOnCloseResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTimeoutOnCloseResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgTimeoutOnCloseResponse({ value: tx_38.MsgTimeoutOnCloseResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTimeoutOnCloseResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        timeout({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Timeout", value: channel_1.Timeout.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Timeout: Could not create message: ' + e.message);
            }
        },
        errorReceipt({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.ErrorReceipt", value: upgrade_1.ErrorReceipt.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ErrorReceipt: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeAck({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAck", value: tx_1.MsgChannelUpgradeAck.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeAck: Could not create message: ' + e.message);
            }
        },
        msgPruneAcknowledgements({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgements", value: tx_2.MsgPruneAcknowledgements.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgPruneAcknowledgements: Could not create message: ' + e.message);
            }
        },
        queryUnreceivedPacketsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse", value: query_1.QueryUnreceivedPacketsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnreceivedPacketsResponse: Could not create message: ' + e.message);
            }
        },
        queryNextSequenceSendResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendResponse", value: query_2.QueryNextSequenceSendResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryNextSequenceSendResponse: Could not create message: ' + e.message);
            }
        },
        msgTimeoutOnClose({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose", value: tx_3.MsgTimeoutOnClose.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTimeoutOnClose: Could not create message: ' + e.message);
            }
        },
        queryPacketAcknowledgementsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest", value: query_3.QueryPacketAcknowledgementsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketAcknowledgementsRequest: Could not create message: ' + e.message);
            }
        },
        msgChannelCloseInitResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse", value: tx_4.MsgChannelCloseInitResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelCloseInitResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeOpenResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpenResponse", value: tx_5.MsgChannelUpgradeOpenResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeOpenResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgUpdateParamsResponse", value: tx_6.MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelCloseConfirmResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse", value: tx_7.MsgChannelCloseConfirmResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelCloseConfirmResponse: Could not create message: ' + e.message);
            }
        },
        queryPacketAcknowledgementRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest", value: query_4.QueryPacketAcknowledgementRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketAcknowledgementRequest: Could not create message: ' + e.message);
            }
        },
        queryPacketAcknowledgementsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse", value: query_5.QueryPacketAcknowledgementsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketAcknowledgementsResponse: Could not create message: ' + e.message);
            }
        },
        queryNextSequenceReceiveRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest", value: query_6.QueryNextSequenceReceiveRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryNextSequenceReceiveRequest: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Params", value: channel_2.Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenAckResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse", value: tx_8.MsgChannelOpenAckResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenAckResponse: Could not create message: ' + e.message);
            }
        },
        msgAcknowledgementResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse", value: tx_9.MsgAcknowledgementResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAcknowledgementResponse: Could not create message: ' + e.message);
            }
        },
        upgrade({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Upgrade", value: upgrade_2.Upgrade.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Upgrade: Could not create message: ' + e.message);
            }
        },
        packetSequence({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.PacketSequence", value: genesis_1.PacketSequence.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:PacketSequence: Could not create message: ' + e.message);
            }
        },
        msgAcknowledgement({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement", value: tx_10.MsgAcknowledgement.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAcknowledgement: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeCancel({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancel", value: tx_11.MsgChannelUpgradeCancel.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeCancel: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenInit({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit", value: tx_12.MsgChannelOpenInit.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenInit: Could not create message: ' + e.message);
            }
        },
        queryChannelResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelResponse", value: query_7.QueryChannelResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelResponse: Could not create message: ' + e.message);
            }
        },
        queryUpgradeResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUpgradeResponse", value: query_8.QueryUpgradeResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUpgradeResponse: Could not create message: ' + e.message);
            }
        },
        queryChannelsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest", value: query_9.QueryChannelsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelsRequest: Could not create message: ' + e.message);
            }
        },
        queryPacketReceiptResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse", value: query_10.QueryPacketReceiptResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketReceiptResponse: Could not create message: ' + e.message);
            }
        },
        queryUnreceivedAcksResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse", value: query_11.QueryUnreceivedAcksResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnreceivedAcksResponse: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.GenesisState", value: genesis_2.GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenAck({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck", value: tx_13.MsgChannelOpenAck.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenAck: Could not create message: ' + e.message);
            }
        },
        msgRecvPacket({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgRecvPacket", value: tx_14.MsgRecvPacket.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRecvPacket: Could not create message: ' + e.message);
            }
        },
        packet({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Packet", value: channel_3.Packet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Packet: Could not create message: ' + e.message);
            }
        },
        packetState({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.PacketState", value: channel_4.PacketState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:PacketState: Could not create message: ' + e.message);
            }
        },
        queryNextSequenceReceiveResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse", value: query_12.QueryNextSequenceReceiveResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryNextSequenceReceiveResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenInitResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse", value: tx_15.MsgChannelOpenInitResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenInitResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeConfirmResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirmResponse", value: tx_16.MsgChannelUpgradeConfirmResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeConfirmResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeTimeoutResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeoutResponse", value: tx_17.MsgChannelUpgradeTimeoutResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeTimeoutResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgUpdateParams", value: tx_18.MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        queryChannelClientStateResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse", value: query_13.QueryChannelClientStateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelClientStateResponse: Could not create message: ' + e.message);
            }
        },
        queryChannelConsensusStateResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse", value: query_14.QueryChannelConsensusStateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelConsensusStateResponse: Could not create message: ' + e.message);
            }
        },
        queryPacketCommitmentResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse", value: query_15.QueryPacketCommitmentResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketCommitmentResponse: Could not create message: ' + e.message);
            }
        },
        queryUnreceivedAcksRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest", value: query_16.QueryUnreceivedAcksRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnreceivedAcksRequest: Could not create message: ' + e.message);
            }
        },
        acknowledgement({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Acknowledgement", value: channel_5.Acknowledgement.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Acknowledgement: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeInit({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInit", value: tx_19.MsgChannelUpgradeInit.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeInit: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeTry({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTry", value: tx_20.MsgChannelUpgradeTry.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeTry: Could not create message: ' + e.message);
            }
        },
        packetId({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.PacketId", value: channel_6.PacketId.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:PacketId: Could not create message: ' + e.message);
            }
        },
        queryChannelClientStateRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest", value: query_17.QueryChannelClientStateRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelClientStateRequest: Could not create message: ' + e.message);
            }
        },
        queryChannelConsensusStateRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest", value: query_18.QueryChannelConsensusStateRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelConsensusStateRequest: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenTry({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry", value: tx_21.MsgChannelOpenTry.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenTry: Could not create message: ' + e.message);
            }
        },
        queryUpgradeRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUpgradeRequest", value: query_19.QueryUpgradeRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUpgradeRequest: Could not create message: ' + e.message);
            }
        },
        queryPacketAcknowledgementResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse", value: query_20.QueryPacketAcknowledgementResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketAcknowledgementResponse: Could not create message: ' + e.message);
            }
        },
        queryChannelParamsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelParamsRequest", value: query_21.QueryChannelParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelParamsRequest: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenTryResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse", value: tx_22.MsgChannelOpenTryResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenTryResponse: Could not create message: ' + e.message);
            }
        },
        upgradeFields({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.UpgradeFields", value: upgrade_3.UpgradeFields.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:UpgradeFields: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeOpen({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpen", value: tx_23.MsgChannelUpgradeOpen.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeOpen: Could not create message: ' + e.message);
            }
        },
        counterparty({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Counterparty", value: channel_7.Counterparty.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Counterparty: Could not create message: ' + e.message);
            }
        },
        queryChannelRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelRequest", value: query_22.QueryChannelRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelRequest: Could not create message: ' + e.message);
            }
        },
        queryPacketReceiptRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest", value: query_23.QueryPacketReceiptRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketReceiptRequest: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeCancelResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancelResponse", value: tx_24.MsgChannelUpgradeCancelResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeCancelResponse: Could not create message: ' + e.message);
            }
        },
        msgPruneAcknowledgementsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgementsResponse", value: tx_25.MsgPruneAcknowledgementsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgPruneAcknowledgementsResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenConfirm({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm", value: tx_26.MsgChannelOpenConfirm.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenConfirm: Could not create message: ' + e.message);
            }
        },
        channel({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.Channel", value: channel_8.Channel.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Channel: Could not create message: ' + e.message);
            }
        },
        queryPacketCommitmentRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest", value: query_24.QueryPacketCommitmentRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketCommitmentRequest: Could not create message: ' + e.message);
            }
        },
        queryNextSequenceSendRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendRequest", value: query_25.QueryNextSequenceSendRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryNextSequenceSendRequest: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeInitResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInitResponse", value: tx_27.MsgChannelUpgradeInitResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeInitResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeConfirm({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirm", value: tx_28.MsgChannelUpgradeConfirm.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeConfirm: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeTimeout({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeout", value: tx_29.MsgChannelUpgradeTimeout.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeTimeout: Could not create message: ' + e.message);
            }
        },
        msgChannelCloseInit({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit", value: tx_30.MsgChannelCloseInit.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelCloseInit: Could not create message: ' + e.message);
            }
        },
        queryChannelsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse", value: query_26.QueryChannelsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelsResponse: Could not create message: ' + e.message);
            }
        },
        queryPacketCommitmentsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse", value: query_27.QueryPacketCommitmentsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketCommitmentsResponse: Could not create message: ' + e.message);
            }
        },
        msgTimeoutResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse", value: tx_31.MsgTimeoutResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTimeoutResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeTryResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTryResponse", value: tx_32.MsgChannelUpgradeTryResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeTryResponse: Could not create message: ' + e.message);
            }
        },
        queryUpgradeErrorResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorResponse", value: query_28.QueryUpgradeErrorResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUpgradeErrorResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelOpenConfirmResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse", value: tx_33.MsgChannelOpenConfirmResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelOpenConfirmResponse: Could not create message: ' + e.message);
            }
        },
        msgChannelCloseConfirm({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm", value: tx_34.MsgChannelCloseConfirm.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelCloseConfirm: Could not create message: ' + e.message);
            }
        },
        msgTimeout({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgTimeout", value: tx_35.MsgTimeout.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTimeout: Could not create message: ' + e.message);
            }
        },
        queryConnectionChannelsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest", value: query_29.QueryConnectionChannelsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryConnectionChannelsRequest: Could not create message: ' + e.message);
            }
        },
        queryConnectionChannelsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse", value: query_30.QueryConnectionChannelsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryConnectionChannelsResponse: Could not create message: ' + e.message);
            }
        },
        queryUpgradeErrorRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorRequest", value: query_31.QueryUpgradeErrorRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUpgradeErrorRequest: Could not create message: ' + e.message);
            }
        },
        identifiedChannel({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.IdentifiedChannel", value: channel_9.IdentifiedChannel.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:IdentifiedChannel: Could not create message: ' + e.message);
            }
        },
        msgChannelUpgradeAckResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAckResponse", value: tx_36.MsgChannelUpgradeAckResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChannelUpgradeAckResponse: Could not create message: ' + e.message);
            }
        },
        queryPacketCommitmentsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest", value: query_32.QueryPacketCommitmentsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPacketCommitmentsRequest: Could not create message: ' + e.message);
            }
        },
        queryUnreceivedPacketsRequest({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest", value: query_33.QueryUnreceivedPacketsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnreceivedPacketsRequest: Could not create message: ' + e.message);
            }
        },
        queryChannelParamsResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.QueryChannelParamsResponse", value: query_34.QueryChannelParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryChannelParamsResponse: Could not create message: ' + e.message);
            }
        },
        msgRecvPacketResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse", value: tx_37.MsgRecvPacketResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRecvPacketResponse: Could not create message: ' + e.message);
            }
        },
        msgTimeoutOnCloseResponse({ value }) {
            try {
                return { typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse", value: tx_38.MsgTimeoutOnCloseResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTimeoutOnCloseResponse: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            IbcCoreChannelV1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
