"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryPoolResponse = exports.QueryValidatorDelegationsResponse = exports.MsgCancelUnbondingDelegation = exports.MsgUndelegate = exports.HistoricalInfo = exports.QueryDelegatorUnbondingDelegationsResponse = exports.QueryValidatorRequest = exports.QueryValidatorsRequest = exports.StakeAuthorization = exports.MsgUndelegateResponse = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryDelegationRequest = exports.Pool = exports.Description = exports.MsgUpdateParams = exports.MsgEditValidator = exports.CommissionRates = exports.GenesisState = exports.QueryDelegatorDelegationsRequest = exports.QueryUnbondingDelegationRequest = exports.QueryValidatorUnbondingDelegationsRequest = exports.MsgDelegate = exports.Params = exports.RedelegationResponse = exports.QueryHistoricalInfoResponse = exports.ValidatorUpdates = exports.QueryRedelegationsRequest = exports.MsgEditValidatorResponse = exports.QueryDelegatorValidatorRequest = exports.QueryRedelegationsResponse = exports.QueryUnbondingDelegationResponse = exports.Delegation = exports.QueryValidatorUnbondingDelegationsResponse = exports.MsgCancelUnbondingDelegationResponse = exports.RedelegationEntryResponse = exports.DVVTriplets = exports.ValAddresses = exports.UnbondingDelegation = exports.QueryDelegationResponse = exports.MsgUpdateParamsResponse = exports.MsgBeginRedelegateResponse = exports.DelegationResponse = exports.LastValidatorPower = exports.QueryDelegatorValidatorResponse = exports.MsgCreateValidator = exports.MsgCreateValidatorResponse = exports.QueryHistoricalInfoRequest = exports.QueryValidatorsResponse = exports.MsgBeginRedelegate = void 0;
exports.queryClient = exports.txClient = exports.registry = exports.Validator = exports.QueryPoolRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryValidatorResponse = exports.DVPair = exports.StakeAuthorization_Validators = exports.UnbondingDelegationEntry = exports.QueryDelegatorUnbondingDelegationsRequest = exports.QueryDelegatorDelegationsResponse = exports.QueryValidatorDelegationsRequest = exports.MsgDelegateResponse = exports.DVVTriplet = exports.DVPairs = exports.Commission = exports.Redelegation = exports.RedelegationEntry = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const tx_1 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgBeginRedelegate", { enumerable: true, get: function () { return tx_1.MsgBeginRedelegate; } });
const query_1 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorsResponse", { enumerable: true, get: function () { return query_1.QueryValidatorsResponse; } });
const query_2 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryHistoricalInfoRequest", { enumerable: true, get: function () { return query_2.QueryHistoricalInfoRequest; } });
const tx_2 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgCreateValidatorResponse", { enumerable: true, get: function () { return tx_2.MsgCreateValidatorResponse; } });
const tx_3 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgCreateValidator", { enumerable: true, get: function () { return tx_3.MsgCreateValidator; } });
const query_3 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorValidatorResponse", { enumerable: true, get: function () { return query_3.QueryDelegatorValidatorResponse; } });
const genesis_1 = require("./types/cosmos/staking/v1beta1/genesis");
Object.defineProperty(exports, "LastValidatorPower", { enumerable: true, get: function () { return genesis_1.LastValidatorPower; } });
const staking_1 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "DelegationResponse", { enumerable: true, get: function () { return staking_1.DelegationResponse; } });
const tx_4 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgBeginRedelegateResponse", { enumerable: true, get: function () { return tx_4.MsgBeginRedelegateResponse; } });
const tx_5 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParamsResponse", { enumerable: true, get: function () { return tx_5.MsgUpdateParamsResponse; } });
const query_4 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegationResponse", { enumerable: true, get: function () { return query_4.QueryDelegationResponse; } });
const staking_2 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "UnbondingDelegation", { enumerable: true, get: function () { return staking_2.UnbondingDelegation; } });
const staking_3 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "ValAddresses", { enumerable: true, get: function () { return staking_3.ValAddresses; } });
const staking_4 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "DVVTriplets", { enumerable: true, get: function () { return staking_4.DVVTriplets; } });
const staking_5 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "RedelegationEntryResponse", { enumerable: true, get: function () { return staking_5.RedelegationEntryResponse; } });
const tx_6 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgCancelUnbondingDelegationResponse", { enumerable: true, get: function () { return tx_6.MsgCancelUnbondingDelegationResponse; } });
const query_5 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorUnbondingDelegationsResponse", { enumerable: true, get: function () { return query_5.QueryValidatorUnbondingDelegationsResponse; } });
const staking_6 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Delegation", { enumerable: true, get: function () { return staking_6.Delegation; } });
const query_6 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryUnbondingDelegationResponse", { enumerable: true, get: function () { return query_6.QueryUnbondingDelegationResponse; } });
const query_7 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryRedelegationsResponse", { enumerable: true, get: function () { return query_7.QueryRedelegationsResponse; } });
const query_8 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorValidatorRequest", { enumerable: true, get: function () { return query_8.QueryDelegatorValidatorRequest; } });
const tx_7 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgEditValidatorResponse", { enumerable: true, get: function () { return tx_7.MsgEditValidatorResponse; } });
const query_9 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryRedelegationsRequest", { enumerable: true, get: function () { return query_9.QueryRedelegationsRequest; } });
const staking_7 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "ValidatorUpdates", { enumerable: true, get: function () { return staking_7.ValidatorUpdates; } });
const query_10 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryHistoricalInfoResponse", { enumerable: true, get: function () { return query_10.QueryHistoricalInfoResponse; } });
const staking_8 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "RedelegationResponse", { enumerable: true, get: function () { return staking_8.RedelegationResponse; } });
const staking_9 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Params", { enumerable: true, get: function () { return staking_9.Params; } });
const tx_8 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgDelegate", { enumerable: true, get: function () { return tx_8.MsgDelegate; } });
const query_11 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorUnbondingDelegationsRequest", { enumerable: true, get: function () { return query_11.QueryValidatorUnbondingDelegationsRequest; } });
const query_12 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryUnbondingDelegationRequest", { enumerable: true, get: function () { return query_12.QueryUnbondingDelegationRequest; } });
const query_13 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorDelegationsRequest", { enumerable: true, get: function () { return query_13.QueryDelegatorDelegationsRequest; } });
const genesis_2 = require("./types/cosmos/staking/v1beta1/genesis");
Object.defineProperty(exports, "GenesisState", { enumerable: true, get: function () { return genesis_2.GenesisState; } });
const staking_10 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "CommissionRates", { enumerable: true, get: function () { return staking_10.CommissionRates; } });
const tx_9 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgEditValidator", { enumerable: true, get: function () { return tx_9.MsgEditValidator; } });
const tx_10 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParams", { enumerable: true, get: function () { return tx_10.MsgUpdateParams; } });
const staking_11 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Description", { enumerable: true, get: function () { return staking_11.Description; } });
const staking_12 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Pool", { enumerable: true, get: function () { return staking_12.Pool; } });
const query_14 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegationRequest", { enumerable: true, get: function () { return query_14.QueryDelegationRequest; } });
const query_15 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryParamsRequest", { enumerable: true, get: function () { return query_15.QueryParamsRequest; } });
const query_16 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryParamsResponse", { enumerable: true, get: function () { return query_16.QueryParamsResponse; } });
const tx_11 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgUndelegateResponse", { enumerable: true, get: function () { return tx_11.MsgUndelegateResponse; } });
const authz_1 = require("./types/cosmos/staking/v1beta1/authz");
Object.defineProperty(exports, "StakeAuthorization", { enumerable: true, get: function () { return authz_1.StakeAuthorization; } });
const query_17 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorsRequest", { enumerable: true, get: function () { return query_17.QueryValidatorsRequest; } });
const query_18 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorRequest", { enumerable: true, get: function () { return query_18.QueryValidatorRequest; } });
const query_19 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorUnbondingDelegationsResponse", { enumerable: true, get: function () { return query_19.QueryDelegatorUnbondingDelegationsResponse; } });
const staking_13 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "HistoricalInfo", { enumerable: true, get: function () { return staking_13.HistoricalInfo; } });
const tx_12 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgUndelegate", { enumerable: true, get: function () { return tx_12.MsgUndelegate; } });
const tx_13 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgCancelUnbondingDelegation", { enumerable: true, get: function () { return tx_13.MsgCancelUnbondingDelegation; } });
const query_20 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorDelegationsResponse", { enumerable: true, get: function () { return query_20.QueryValidatorDelegationsResponse; } });
const query_21 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryPoolResponse", { enumerable: true, get: function () { return query_21.QueryPoolResponse; } });
const staking_14 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "RedelegationEntry", { enumerable: true, get: function () { return staking_14.RedelegationEntry; } });
const staking_15 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Redelegation", { enumerable: true, get: function () { return staking_15.Redelegation; } });
const staking_16 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Commission", { enumerable: true, get: function () { return staking_16.Commission; } });
const staking_17 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "DVPairs", { enumerable: true, get: function () { return staking_17.DVPairs; } });
const staking_18 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "DVVTriplet", { enumerable: true, get: function () { return staking_18.DVVTriplet; } });
const tx_14 = require("./types/cosmos/staking/v1beta1/tx");
Object.defineProperty(exports, "MsgDelegateResponse", { enumerable: true, get: function () { return tx_14.MsgDelegateResponse; } });
const query_22 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorDelegationsRequest", { enumerable: true, get: function () { return query_22.QueryValidatorDelegationsRequest; } });
const query_23 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorDelegationsResponse", { enumerable: true, get: function () { return query_23.QueryDelegatorDelegationsResponse; } });
const query_24 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorUnbondingDelegationsRequest", { enumerable: true, get: function () { return query_24.QueryDelegatorUnbondingDelegationsRequest; } });
const staking_19 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "UnbondingDelegationEntry", { enumerable: true, get: function () { return staking_19.UnbondingDelegationEntry; } });
const authz_2 = require("./types/cosmos/staking/v1beta1/authz");
Object.defineProperty(exports, "StakeAuthorization_Validators", { enumerable: true, get: function () { return authz_2.StakeAuthorization_Validators; } });
const staking_20 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "DVPair", { enumerable: true, get: function () { return staking_20.DVPair; } });
const query_25 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryValidatorResponse", { enumerable: true, get: function () { return query_25.QueryValidatorResponse; } });
const query_26 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorValidatorsRequest", { enumerable: true, get: function () { return query_26.QueryDelegatorValidatorsRequest; } });
const query_27 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryDelegatorValidatorsResponse", { enumerable: true, get: function () { return query_27.QueryDelegatorValidatorsResponse; } });
const query_28 = require("./types/cosmos/staking/v1beta1/query");
Object.defineProperty(exports, "QueryPoolRequest", { enumerable: true, get: function () { return query_28.QueryPoolRequest; } });
const staking_21 = require("./types/cosmos/staking/v1beta1/staking");
Object.defineProperty(exports, "Validator", { enumerable: true, get: function () { return staking_21.Validator; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgBeginRedelegate({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBeginRedelegate: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgBeginRedelegate({ value: tx_1.MsgBeginRedelegate.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBeginRedelegate: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorsResponse({ value: query_1.QueryValidatorsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryHistoricalInfoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryHistoricalInfoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryHistoricalInfoRequest({ value: query_2.QueryHistoricalInfoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryHistoricalInfoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateValidatorResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateValidatorResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgCreateValidatorResponse({ value: tx_2.MsgCreateValidatorResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateValidatorResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateValidator({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateValidator: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgCreateValidator({ value: tx_3.MsgCreateValidator.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateValidator: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorValidatorResponse({ value: query_3.QueryDelegatorValidatorResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendLastValidatorPower({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendLastValidatorPower: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.lastValidatorPower({ value: genesis_1.LastValidatorPower.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendLastValidatorPower: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegationResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegationResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.delegationResponse({ value: staking_1.DelegationResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegationResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBeginRedelegateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBeginRedelegateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgBeginRedelegateResponse({ value: tx_4.MsgBeginRedelegateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBeginRedelegateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParamsResponse({ value: tx_5.MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegationResponse({ value: query_4.QueryDelegationResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendUnbondingDelegation({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendUnbondingDelegation: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.unbondingDelegation({ value: staking_2.UnbondingDelegation.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendUnbondingDelegation: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValAddresses({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValAddresses: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.valAddresses({ value: staking_3.ValAddresses.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValAddresses: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDVVTriplets({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDVVTriplets: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.dvvtriplets({ value: staking_4.DVVTriplets.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDVVTriplets: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendRedelegationEntryResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendRedelegationEntryResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.redelegationEntryResponse({ value: staking_5.RedelegationEntryResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendRedelegationEntryResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelUnbondingDelegationResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelUnbondingDelegationResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgCancelUnbondingDelegationResponse({ value: tx_6.MsgCancelUnbondingDelegationResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelUnbondingDelegationResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorUnbondingDelegationsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorUnbondingDelegationsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorUnbondingDelegationsResponse({ value: query_5.QueryValidatorUnbondingDelegationsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorUnbondingDelegationsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegation({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegation: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.delegation({ value: staking_6.Delegation.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegation: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnbondingDelegationResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnbondingDelegationResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnbondingDelegationResponse({ value: query_6.QueryUnbondingDelegationResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnbondingDelegationResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryRedelegationsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryRedelegationsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryRedelegationsResponse({ value: query_7.QueryRedelegationsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryRedelegationsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorValidatorRequest({ value: query_8.QueryDelegatorValidatorRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgEditValidatorResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgEditValidatorResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgEditValidatorResponse({ value: tx_7.MsgEditValidatorResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgEditValidatorResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryRedelegationsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryRedelegationsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryRedelegationsRequest({ value: query_9.QueryRedelegationsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryRedelegationsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorUpdates({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorUpdates: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.validatorUpdates({ value: staking_7.ValidatorUpdates.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorUpdates: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryHistoricalInfoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryHistoricalInfoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryHistoricalInfoResponse({ value: query_10.QueryHistoricalInfoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryHistoricalInfoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendRedelegationResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendRedelegationResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.redelegationResponse({ value: staking_8.RedelegationResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendRedelegationResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.params({ value: staking_9.Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDelegate({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDelegate: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgDelegate({ value: tx_8.MsgDelegate.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDelegate: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorUnbondingDelegationsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorUnbondingDelegationsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorUnbondingDelegationsRequest({ value: query_11.QueryValidatorUnbondingDelegationsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorUnbondingDelegationsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryUnbondingDelegationRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryUnbondingDelegationRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryUnbondingDelegationRequest({ value: query_12.QueryUnbondingDelegationRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryUnbondingDelegationRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorDelegationsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorDelegationsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorDelegationsRequest({ value: query_13.QueryDelegatorDelegationsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorDelegationsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.genesisState({ value: genesis_2.GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCommissionRates({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCommissionRates: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.commissionRates({ value: staking_10.CommissionRates.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCommissionRates: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgEditValidator({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgEditValidator: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgEditValidator({ value: tx_9.MsgEditValidator.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgEditValidator: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParams({ value: tx_10.MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDescription({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDescription: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.description({ value: staking_11.Description.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDescription: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendPool({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendPool: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.pool({ value: staking_12.Pool.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendPool: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegationRequest({ value: query_14.QueryDelegationRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsRequest({ value: query_15.QueryParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsResponse({ value: query_16.QueryParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUndelegateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUndelegateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUndelegateResponse({ value: tx_11.MsgUndelegateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUndelegateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendStakeAuthorization({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendStakeAuthorization: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.stakeAuthorization({ value: authz_1.StakeAuthorization.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendStakeAuthorization: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorsRequest({ value: query_17.QueryValidatorsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorRequest({ value: query_18.QueryValidatorRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorUnbondingDelegationsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorUnbondingDelegationsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorUnbondingDelegationsResponse({ value: query_19.QueryDelegatorUnbondingDelegationsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorUnbondingDelegationsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendHistoricalInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendHistoricalInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.historicalInfo({ value: staking_13.HistoricalInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendHistoricalInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUndelegate({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUndelegate: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUndelegate({ value: tx_12.MsgUndelegate.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUndelegate: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelUnbondingDelegation({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelUnbondingDelegation: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgCancelUnbondingDelegation({ value: tx_13.MsgCancelUnbondingDelegation.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelUnbondingDelegation: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorDelegationsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorDelegationsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorDelegationsResponse({ value: query_20.QueryValidatorDelegationsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorDelegationsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPoolResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPoolResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPoolResponse({ value: query_21.QueryPoolResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPoolResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendRedelegationEntry({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendRedelegationEntry: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.redelegationEntry({ value: staking_14.RedelegationEntry.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendRedelegationEntry: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendRedelegation({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendRedelegation: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.redelegation({ value: staking_15.Redelegation.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendRedelegation: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCommission({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCommission: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.commission({ value: staking_16.Commission.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCommission: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDVPairs({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDVPairs: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.dvpairs({ value: staking_17.DVPairs.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDVPairs: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDVVTriplet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDVVTriplet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.dvvtriplet({ value: staking_18.DVVTriplet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDVVTriplet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDelegateResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDelegateResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgDelegateResponse({ value: tx_14.MsgDelegateResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDelegateResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorDelegationsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorDelegationsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorDelegationsRequest({ value: query_22.QueryValidatorDelegationsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorDelegationsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorDelegationsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorDelegationsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorDelegationsResponse({ value: query_23.QueryDelegatorDelegationsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorDelegationsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorUnbondingDelegationsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorUnbondingDelegationsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorUnbondingDelegationsRequest({ value: query_24.QueryDelegatorUnbondingDelegationsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorUnbondingDelegationsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendUnbondingDelegationEntry({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendUnbondingDelegationEntry: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.unbondingDelegationEntry({ value: staking_19.UnbondingDelegationEntry.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendUnbondingDelegationEntry: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendStakeAuthorization_Validators({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendStakeAuthorization_Validators: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.stakeAuthorizationValidators({ value: authz_2.StakeAuthorization_Validators.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendStakeAuthorization_Validators: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDVPair({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDVPair: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.dvpair({ value: staking_20.DVPair.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDVPair: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryValidatorResponse({ value: query_25.QueryValidatorResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorValidatorsRequest({ value: query_26.QueryDelegatorValidatorsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDelegatorValidatorsResponse({ value: query_27.QueryDelegatorValidatorsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryPoolRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryPoolRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryPoolRequest({ value: query_28.QueryPoolRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryPoolRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidator({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidator: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.validator({ value: staking_21.Validator.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidator: Could not broadcast Tx: ' + e.message);
            }
        },
        msgBeginRedelegate({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate", value: tx_1.MsgBeginRedelegate.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBeginRedelegate: Could not create message: ' + e.message);
            }
        },
        queryValidatorsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse", value: query_1.QueryValidatorsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorsResponse: Could not create message: ' + e.message);
            }
        },
        queryHistoricalInfoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest", value: query_2.QueryHistoricalInfoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryHistoricalInfoRequest: Could not create message: ' + e.message);
            }
        },
        msgCreateValidatorResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse", value: tx_2.MsgCreateValidatorResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateValidatorResponse: Could not create message: ' + e.message);
            }
        },
        msgCreateValidator({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator", value: tx_3.MsgCreateValidator.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateValidator: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse", value: query_3.QueryDelegatorValidatorResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorResponse: Could not create message: ' + e.message);
            }
        },
        lastValidatorPower({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.LastValidatorPower", value: genesis_1.LastValidatorPower.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:LastValidatorPower: Could not create message: ' + e.message);
            }
        },
        delegationResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.DelegationResponse", value: staking_1.DelegationResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DelegationResponse: Could not create message: ' + e.message);
            }
        },
        msgBeginRedelegateResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse", value: tx_4.MsgBeginRedelegateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBeginRedelegateResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse", value: tx_5.MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegationResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse", value: query_4.QueryDelegationResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationResponse: Could not create message: ' + e.message);
            }
        },
        unbondingDelegation({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation", value: staking_2.UnbondingDelegation.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:UnbondingDelegation: Could not create message: ' + e.message);
            }
        },
        valAddresses({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.ValAddresses", value: staking_3.ValAddresses.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValAddresses: Could not create message: ' + e.message);
            }
        },
        dvvtriplets({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.DVVTriplets", value: staking_4.DVVTriplets.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DVVTriplets: Could not create message: ' + e.message);
            }
        },
        redelegationEntryResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse", value: staking_5.RedelegationEntryResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:RedelegationEntryResponse: Could not create message: ' + e.message);
            }
        },
        msgCancelUnbondingDelegationResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse", value: tx_6.MsgCancelUnbondingDelegationResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelUnbondingDelegationResponse: Could not create message: ' + e.message);
            }
        },
        queryValidatorUnbondingDelegationsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse", value: query_5.QueryValidatorUnbondingDelegationsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorUnbondingDelegationsResponse: Could not create message: ' + e.message);
            }
        },
        delegation({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Delegation", value: staking_6.Delegation.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Delegation: Could not create message: ' + e.message);
            }
        },
        queryUnbondingDelegationResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse", value: query_6.QueryUnbondingDelegationResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnbondingDelegationResponse: Could not create message: ' + e.message);
            }
        },
        queryRedelegationsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse", value: query_7.QueryRedelegationsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryRedelegationsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest", value: query_8.QueryDelegatorValidatorRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorRequest: Could not create message: ' + e.message);
            }
        },
        msgEditValidatorResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse", value: tx_7.MsgEditValidatorResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgEditValidatorResponse: Could not create message: ' + e.message);
            }
        },
        queryRedelegationsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest", value: query_9.QueryRedelegationsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryRedelegationsRequest: Could not create message: ' + e.message);
            }
        },
        validatorUpdates({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates", value: staking_7.ValidatorUpdates.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorUpdates: Could not create message: ' + e.message);
            }
        },
        queryHistoricalInfoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse", value: query_10.QueryHistoricalInfoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryHistoricalInfoResponse: Could not create message: ' + e.message);
            }
        },
        redelegationResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse", value: staking_8.RedelegationResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:RedelegationResponse: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Params", value: staking_9.Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        msgDelegate({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgDelegate", value: tx_8.MsgDelegate.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDelegate: Could not create message: ' + e.message);
            }
        },
        queryValidatorUnbondingDelegationsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest", value: query_11.QueryValidatorUnbondingDelegationsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorUnbondingDelegationsRequest: Could not create message: ' + e.message);
            }
        },
        queryUnbondingDelegationRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest", value: query_12.QueryUnbondingDelegationRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryUnbondingDelegationRequest: Could not create message: ' + e.message);
            }
        },
        queryDelegatorDelegationsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest", value: query_13.QueryDelegatorDelegationsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorDelegationsRequest: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.GenesisState", value: genesis_2.GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        commissionRates({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.CommissionRates", value: staking_10.CommissionRates.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:CommissionRates: Could not create message: ' + e.message);
            }
        },
        msgEditValidator({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator", value: tx_9.MsgEditValidator.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgEditValidator: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams", value: tx_10.MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        description({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Description", value: staking_11.Description.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Description: Could not create message: ' + e.message);
            }
        },
        pool({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Pool", value: staking_12.Pool.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Pool: Could not create message: ' + e.message);
            }
        },
        queryDelegationRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest", value: query_14.QueryDelegationRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationRequest: Could not create message: ' + e.message);
            }
        },
        queryParamsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest", value: query_15.QueryParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message);
            }
        },
        queryParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse", value: query_16.QueryParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message);
            }
        },
        msgUndelegateResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse", value: tx_11.MsgUndelegateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUndelegateResponse: Could not create message: ' + e.message);
            }
        },
        stakeAuthorization({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.StakeAuthorization", value: authz_1.StakeAuthorization.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:StakeAuthorization: Could not create message: ' + e.message);
            }
        },
        queryValidatorsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest", value: query_17.QueryValidatorsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorsRequest: Could not create message: ' + e.message);
            }
        },
        queryValidatorRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest", value: query_18.QueryValidatorRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorRequest: Could not create message: ' + e.message);
            }
        },
        queryDelegatorUnbondingDelegationsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse", value: query_19.QueryDelegatorUnbondingDelegationsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorUnbondingDelegationsResponse: Could not create message: ' + e.message);
            }
        },
        historicalInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo", value: staking_13.HistoricalInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:HistoricalInfo: Could not create message: ' + e.message);
            }
        },
        msgUndelegate({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate", value: tx_12.MsgUndelegate.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUndelegate: Could not create message: ' + e.message);
            }
        },
        msgCancelUnbondingDelegation({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", value: tx_13.MsgCancelUnbondingDelegation.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelUnbondingDelegation: Could not create message: ' + e.message);
            }
        },
        queryValidatorDelegationsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse", value: query_20.QueryValidatorDelegationsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorDelegationsResponse: Could not create message: ' + e.message);
            }
        },
        queryPoolResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse", value: query_21.QueryPoolResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPoolResponse: Could not create message: ' + e.message);
            }
        },
        redelegationEntry({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry", value: staking_14.RedelegationEntry.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:RedelegationEntry: Could not create message: ' + e.message);
            }
        },
        redelegation({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Redelegation", value: staking_15.Redelegation.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Redelegation: Could not create message: ' + e.message);
            }
        },
        commission({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Commission", value: staking_16.Commission.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Commission: Could not create message: ' + e.message);
            }
        },
        dvpairs({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.DVPairs", value: staking_17.DVPairs.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DVPairs: Could not create message: ' + e.message);
            }
        },
        dvvtriplet({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.DVVTriplet", value: staking_18.DVVTriplet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DVVTriplet: Could not create message: ' + e.message);
            }
        },
        msgDelegateResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse", value: tx_14.MsgDelegateResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDelegateResponse: Could not create message: ' + e.message);
            }
        },
        queryValidatorDelegationsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest", value: query_22.QueryValidatorDelegationsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorDelegationsRequest: Could not create message: ' + e.message);
            }
        },
        queryDelegatorDelegationsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse", value: query_23.QueryDelegatorDelegationsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorDelegationsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegatorUnbondingDelegationsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest", value: query_24.QueryDelegatorUnbondingDelegationsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorUnbondingDelegationsRequest: Could not create message: ' + e.message);
            }
        },
        unbondingDelegationEntry({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry", value: staking_19.UnbondingDelegationEntry.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:UnbondingDelegationEntry: Could not create message: ' + e.message);
            }
        },
        stakeAuthorizationValidators({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.StakeAuthorization_Validators", value: authz_2.StakeAuthorization_Validators.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:StakeAuthorization_Validators: Could not create message: ' + e.message);
            }
        },
        dvpair({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.DVPair", value: staking_20.DVPair.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DVPair: Could not create message: ' + e.message);
            }
        },
        queryValidatorResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse", value: query_25.QueryValidatorResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest", value: query_26.QueryDelegatorValidatorsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorsRequest: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse", value: query_27.QueryDelegatorValidatorsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorsResponse: Could not create message: ' + e.message);
            }
        },
        queryPoolRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest", value: query_28.QueryPoolRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryPoolRequest: Could not create message: ' + e.message);
            }
        },
        validator({ value }) {
            try {
                return { typeUrl: "/cosmos.staking.v1beta1.Validator", value: staking_21.Validator.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Validator: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosStakingV1Beta1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
