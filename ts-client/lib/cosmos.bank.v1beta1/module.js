"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.QueryDenomMetadataResponse = exports.QuerySpendableBalancesResponse = exports.QuerySendEnabledResponse = exports.QueryTotalSupplyResponse = exports.QueryAllBalancesRequest = exports.MsgSend = exports.QuerySpendableBalanceByDenomResponse = exports.DenomUnit = exports.QueryDenomsMetadataRequest = exports.Supply = exports.MsgSendResponse = exports.QueryDenomOwnersByQueryRequest = exports.QueryParamsResponse = exports.QuerySpendableBalancesRequest = exports.QueryBalanceResponse = exports.MsgMultiSendResponse = exports.QueryDenomMetadataRequest = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyRequest = exports.GenesisState = exports.MsgSetSendEnabled = exports.SendAuthorization = exports.MsgUpdateParamsResponse = exports.QueryBalanceRequest = exports.QueryDenomOwnersResponse = exports.QuerySpendableBalanceByDenomRequest = exports.QueryAllBalancesResponse = exports.SendEnabled = exports.QuerySendEnabledRequest = exports.QueryDenomMetadataByQueryStringRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomMetadataByQueryStringResponse = exports.Output = exports.Params = exports.MsgUpdateParams = exports.MsgMultiSend = exports.Input = exports.DenomOwner = exports.QueryParamsRequest = exports.Metadata = exports.Balance = exports.QueryDenomOwnersByQueryResponse = exports.MsgSetSendEnabledResponse = exports.QueryDenomOwnersRequest = exports.QuerySupplyOfResponse = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const query_1 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySupplyOfResponse", { enumerable: true, get: function () { return query_1.QuerySupplyOfResponse; } });
const query_2 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomOwnersRequest", { enumerable: true, get: function () { return query_2.QueryDenomOwnersRequest; } });
const tx_1 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgSetSendEnabledResponse", { enumerable: true, get: function () { return tx_1.MsgSetSendEnabledResponse; } });
const query_3 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomOwnersByQueryResponse", { enumerable: true, get: function () { return query_3.QueryDenomOwnersByQueryResponse; } });
const genesis_1 = require("./types/cosmos/bank/v1beta1/genesis");
Object.defineProperty(exports, "Balance", { enumerable: true, get: function () { return genesis_1.Balance; } });
const bank_1 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "Metadata", { enumerable: true, get: function () { return bank_1.Metadata; } });
const query_4 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryParamsRequest", { enumerable: true, get: function () { return query_4.QueryParamsRequest; } });
const query_5 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "DenomOwner", { enumerable: true, get: function () { return query_5.DenomOwner; } });
const bank_2 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "Input", { enumerable: true, get: function () { return bank_2.Input; } });
const tx_2 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgMultiSend", { enumerable: true, get: function () { return tx_2.MsgMultiSend; } });
const tx_3 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParams", { enumerable: true, get: function () { return tx_3.MsgUpdateParams; } });
const bank_3 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "Params", { enumerable: true, get: function () { return bank_3.Params; } });
const bank_4 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "Output", { enumerable: true, get: function () { return bank_4.Output; } });
const query_6 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomMetadataByQueryStringResponse", { enumerable: true, get: function () { return query_6.QueryDenomMetadataByQueryStringResponse; } });
const query_7 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomsMetadataResponse", { enumerable: true, get: function () { return query_7.QueryDenomsMetadataResponse; } });
const query_8 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomMetadataByQueryStringRequest", { enumerable: true, get: function () { return query_8.QueryDenomMetadataByQueryStringRequest; } });
const query_9 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySendEnabledRequest", { enumerable: true, get: function () { return query_9.QuerySendEnabledRequest; } });
const bank_5 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "SendEnabled", { enumerable: true, get: function () { return bank_5.SendEnabled; } });
const query_10 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryAllBalancesResponse", { enumerable: true, get: function () { return query_10.QueryAllBalancesResponse; } });
const query_11 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySpendableBalanceByDenomRequest", { enumerable: true, get: function () { return query_11.QuerySpendableBalanceByDenomRequest; } });
const query_12 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomOwnersResponse", { enumerable: true, get: function () { return query_12.QueryDenomOwnersResponse; } });
const query_13 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryBalanceRequest", { enumerable: true, get: function () { return query_13.QueryBalanceRequest; } });
const tx_4 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParamsResponse", { enumerable: true, get: function () { return tx_4.MsgUpdateParamsResponse; } });
const authz_1 = require("./types/cosmos/bank/v1beta1/authz");
Object.defineProperty(exports, "SendAuthorization", { enumerable: true, get: function () { return authz_1.SendAuthorization; } });
const tx_5 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgSetSendEnabled", { enumerable: true, get: function () { return tx_5.MsgSetSendEnabled; } });
const genesis_2 = require("./types/cosmos/bank/v1beta1/genesis");
Object.defineProperty(exports, "GenesisState", { enumerable: true, get: function () { return genesis_2.GenesisState; } });
const query_14 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryTotalSupplyRequest", { enumerable: true, get: function () { return query_14.QueryTotalSupplyRequest; } });
const query_15 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySupplyOfRequest", { enumerable: true, get: function () { return query_15.QuerySupplyOfRequest; } });
const query_16 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomMetadataRequest", { enumerable: true, get: function () { return query_16.QueryDenomMetadataRequest; } });
const tx_6 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgMultiSendResponse", { enumerable: true, get: function () { return tx_6.MsgMultiSendResponse; } });
const query_17 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryBalanceResponse", { enumerable: true, get: function () { return query_17.QueryBalanceResponse; } });
const query_18 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySpendableBalancesRequest", { enumerable: true, get: function () { return query_18.QuerySpendableBalancesRequest; } });
const query_19 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryParamsResponse", { enumerable: true, get: function () { return query_19.QueryParamsResponse; } });
const query_20 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomOwnersByQueryRequest", { enumerable: true, get: function () { return query_20.QueryDenomOwnersByQueryRequest; } });
const tx_7 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgSendResponse", { enumerable: true, get: function () { return tx_7.MsgSendResponse; } });
const bank_6 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "Supply", { enumerable: true, get: function () { return bank_6.Supply; } });
const query_21 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomsMetadataRequest", { enumerable: true, get: function () { return query_21.QueryDenomsMetadataRequest; } });
const bank_7 = require("./types/cosmos/bank/v1beta1/bank");
Object.defineProperty(exports, "DenomUnit", { enumerable: true, get: function () { return bank_7.DenomUnit; } });
const query_22 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySpendableBalanceByDenomResponse", { enumerable: true, get: function () { return query_22.QuerySpendableBalanceByDenomResponse; } });
const tx_8 = require("./types/cosmos/bank/v1beta1/tx");
Object.defineProperty(exports, "MsgSend", { enumerable: true, get: function () { return tx_8.MsgSend; } });
const query_23 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryAllBalancesRequest", { enumerable: true, get: function () { return query_23.QueryAllBalancesRequest; } });
const query_24 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryTotalSupplyResponse", { enumerable: true, get: function () { return query_24.QueryTotalSupplyResponse; } });
const query_25 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySendEnabledResponse", { enumerable: true, get: function () { return query_25.QuerySendEnabledResponse; } });
const query_26 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QuerySpendableBalancesResponse", { enumerable: true, get: function () { return query_26.QuerySpendableBalancesResponse; } });
const query_27 = require("./types/cosmos/bank/v1beta1/query");
Object.defineProperty(exports, "QueryDenomMetadataResponse", { enumerable: true, get: function () { return query_27.QueryDenomMetadataResponse; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendQuerySupplyOfResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySupplyOfResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySupplyOfResponse({ value: query_1.QuerySupplyOfResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySupplyOfResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomOwnersRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomOwnersRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomOwnersRequest({ value: query_2.QueryDenomOwnersRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomOwnersRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetSendEnabledResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetSendEnabledResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgSetSendEnabledResponse({ value: tx_1.MsgSetSendEnabledResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetSendEnabledResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomOwnersByQueryResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomOwnersByQueryResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomOwnersByQueryResponse({ value: query_3.QueryDenomOwnersByQueryResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomOwnersByQueryResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBalance({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBalance: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.balance({ value: genesis_1.Balance.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBalance: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMetadata({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMetadata: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.metadata({ value: bank_1.Metadata.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMetadata: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsRequest({ value: query_4.QueryParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDenomOwner({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDenomOwner: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.denomOwner({ value: query_5.DenomOwner.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDenomOwner: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendInput({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendInput: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.input({ value: bank_2.Input.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendInput: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgMultiSend({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgMultiSend: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgMultiSend({ value: tx_2.MsgMultiSend.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgMultiSend: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParams({ value: tx_3.MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.params({ value: bank_3.Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendOutput({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendOutput: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.output({ value: bank_4.Output.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendOutput: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomMetadataByQueryStringResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomMetadataByQueryStringResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomMetadataByQueryStringResponse({ value: query_6.QueryDenomMetadataByQueryStringResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomMetadataByQueryStringResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomsMetadataResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomsMetadataResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomsMetadataResponse({ value: query_7.QueryDenomsMetadataResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomsMetadataResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomMetadataByQueryStringRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomMetadataByQueryStringRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomMetadataByQueryStringRequest({ value: query_8.QueryDenomMetadataByQueryStringRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomMetadataByQueryStringRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySendEnabledRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySendEnabledRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySendEnabledRequest({ value: query_9.QuerySendEnabledRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySendEnabledRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSendEnabled({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSendEnabled: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.sendEnabled({ value: bank_5.SendEnabled.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSendEnabled: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllBalancesResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllBalancesResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAllBalancesResponse({ value: query_10.QueryAllBalancesResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllBalancesResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySpendableBalanceByDenomRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySpendableBalanceByDenomRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySpendableBalanceByDenomRequest({ value: query_11.QuerySpendableBalanceByDenomRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySpendableBalanceByDenomRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomOwnersResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomOwnersResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomOwnersResponse({ value: query_12.QueryDenomOwnersResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomOwnersResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryBalanceRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryBalanceRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryBalanceRequest({ value: query_13.QueryBalanceRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryBalanceRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParamsResponse({ value: tx_4.MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSendAuthorization({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSendAuthorization: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.sendAuthorization({ value: authz_1.SendAuthorization.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSendAuthorization: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetSendEnabled({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetSendEnabled: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgSetSendEnabled({ value: tx_5.MsgSetSendEnabled.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetSendEnabled: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.genesisState({ value: genesis_2.GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryTotalSupplyRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryTotalSupplyRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryTotalSupplyRequest({ value: query_14.QueryTotalSupplyRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryTotalSupplyRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySupplyOfRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySupplyOfRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySupplyOfRequest({ value: query_15.QuerySupplyOfRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySupplyOfRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomMetadataRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomMetadataRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomMetadataRequest({ value: query_16.QueryDenomMetadataRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomMetadataRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgMultiSendResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgMultiSendResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgMultiSendResponse({ value: tx_6.MsgMultiSendResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgMultiSendResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryBalanceResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryBalanceResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryBalanceResponse({ value: query_17.QueryBalanceResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryBalanceResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySpendableBalancesRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySpendableBalancesRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySpendableBalancesRequest({ value: query_18.QuerySpendableBalancesRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySpendableBalancesRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsResponse({ value: query_19.QueryParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomOwnersByQueryRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomOwnersByQueryRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomOwnersByQueryRequest({ value: query_20.QueryDenomOwnersByQueryRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomOwnersByQueryRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgSendResponse({ value: tx_7.MsgSendResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSupply({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSupply: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.supply({ value: bank_6.Supply.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSupply: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomsMetadataRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomsMetadataRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomsMetadataRequest({ value: query_21.QueryDenomsMetadataRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomsMetadataRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDenomUnit({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDenomUnit: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.denomUnit({ value: bank_7.DenomUnit.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDenomUnit: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySpendableBalanceByDenomResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySpendableBalanceByDenomResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySpendableBalanceByDenomResponse({ value: query_22.QuerySpendableBalanceByDenomResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySpendableBalanceByDenomResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSend({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSend: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgSend({ value: tx_8.MsgSend.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSend: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllBalancesRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllBalancesRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAllBalancesRequest({ value: query_23.QueryAllBalancesRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllBalancesRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryTotalSupplyResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryTotalSupplyResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryTotalSupplyResponse({ value: query_24.QueryTotalSupplyResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryTotalSupplyResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySendEnabledResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySendEnabledResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySendEnabledResponse({ value: query_25.QuerySendEnabledResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySendEnabledResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQuerySpendableBalancesResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQuerySpendableBalancesResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.querySpendableBalancesResponse({ value: query_26.QuerySpendableBalancesResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQuerySpendableBalancesResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDenomMetadataResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDenomMetadataResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryDenomMetadataResponse({ value: query_27.QueryDenomMetadataResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDenomMetadataResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        querySupplyOfResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse", value: query_1.QuerySupplyOfResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySupplyOfResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomOwnersRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest", value: query_2.QueryDenomOwnersRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomOwnersRequest: Could not create message: ' + e.message);
            }
        },
        msgSetSendEnabledResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse", value: tx_1.MsgSetSendEnabledResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetSendEnabledResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomOwnersByQueryResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse", value: query_3.QueryDenomOwnersByQueryResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomOwnersByQueryResponse: Could not create message: ' + e.message);
            }
        },
        balance({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Balance", value: genesis_1.Balance.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Balance: Could not create message: ' + e.message);
            }
        },
        metadata({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Metadata", value: bank_1.Metadata.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Metadata: Could not create message: ' + e.message);
            }
        },
        queryParamsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest", value: query_4.QueryParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message);
            }
        },
        denomOwner({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.DenomOwner", value: query_5.DenomOwner.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DenomOwner: Could not create message: ' + e.message);
            }
        },
        input({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Input", value: bank_2.Input.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Input: Could not create message: ' + e.message);
            }
        },
        msgMultiSend({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend", value: tx_2.MsgMultiSend.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgMultiSend: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams", value: tx_3.MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Params", value: bank_3.Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        output({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Output", value: bank_4.Output.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Output: Could not create message: ' + e.message);
            }
        },
        queryDenomMetadataByQueryStringResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse", value: query_6.QueryDenomMetadataByQueryStringResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomMetadataByQueryStringResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomsMetadataResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse", value: query_7.QueryDenomsMetadataResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomsMetadataResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomMetadataByQueryStringRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest", value: query_8.QueryDenomMetadataByQueryStringRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomMetadataByQueryStringRequest: Could not create message: ' + e.message);
            }
        },
        querySendEnabledRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest", value: query_9.QuerySendEnabledRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySendEnabledRequest: Could not create message: ' + e.message);
            }
        },
        sendEnabled({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.SendEnabled", value: bank_5.SendEnabled.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SendEnabled: Could not create message: ' + e.message);
            }
        },
        queryAllBalancesResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse", value: query_10.QueryAllBalancesResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllBalancesResponse: Could not create message: ' + e.message);
            }
        },
        querySpendableBalanceByDenomRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest", value: query_11.QuerySpendableBalanceByDenomRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySpendableBalanceByDenomRequest: Could not create message: ' + e.message);
            }
        },
        queryDenomOwnersResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse", value: query_12.QueryDenomOwnersResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomOwnersResponse: Could not create message: ' + e.message);
            }
        },
        queryBalanceRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest", value: query_13.QueryBalanceRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryBalanceRequest: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse", value: tx_4.MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        sendAuthorization({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.SendAuthorization", value: authz_1.SendAuthorization.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SendAuthorization: Could not create message: ' + e.message);
            }
        },
        msgSetSendEnabled({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled", value: tx_5.MsgSetSendEnabled.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetSendEnabled: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.GenesisState", value: genesis_2.GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        queryTotalSupplyRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest", value: query_14.QueryTotalSupplyRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryTotalSupplyRequest: Could not create message: ' + e.message);
            }
        },
        querySupplyOfRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest", value: query_15.QuerySupplyOfRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySupplyOfRequest: Could not create message: ' + e.message);
            }
        },
        queryDenomMetadataRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest", value: query_16.QueryDenomMetadataRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomMetadataRequest: Could not create message: ' + e.message);
            }
        },
        msgMultiSendResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse", value: tx_6.MsgMultiSendResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgMultiSendResponse: Could not create message: ' + e.message);
            }
        },
        queryBalanceResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse", value: query_17.QueryBalanceResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryBalanceResponse: Could not create message: ' + e.message);
            }
        },
        querySpendableBalancesRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest", value: query_18.QuerySpendableBalancesRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySpendableBalancesRequest: Could not create message: ' + e.message);
            }
        },
        queryParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse", value: query_19.QueryParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomOwnersByQueryRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest", value: query_20.QueryDenomOwnersByQueryRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomOwnersByQueryRequest: Could not create message: ' + e.message);
            }
        },
        msgSendResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse", value: tx_7.MsgSendResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendResponse: Could not create message: ' + e.message);
            }
        },
        supply({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.Supply", value: bank_6.Supply.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Supply: Could not create message: ' + e.message);
            }
        },
        queryDenomsMetadataRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest", value: query_21.QueryDenomsMetadataRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomsMetadataRequest: Could not create message: ' + e.message);
            }
        },
        denomUnit({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.DenomUnit", value: bank_7.DenomUnit.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DenomUnit: Could not create message: ' + e.message);
            }
        },
        querySpendableBalanceByDenomResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse", value: query_22.QuerySpendableBalanceByDenomResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySpendableBalanceByDenomResponse: Could not create message: ' + e.message);
            }
        },
        msgSend({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.MsgSend", value: tx_8.MsgSend.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSend: Could not create message: ' + e.message);
            }
        },
        queryAllBalancesRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest", value: query_23.QueryAllBalancesRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllBalancesRequest: Could not create message: ' + e.message);
            }
        },
        queryTotalSupplyResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse", value: query_24.QueryTotalSupplyResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryTotalSupplyResponse: Could not create message: ' + e.message);
            }
        },
        querySendEnabledResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse", value: query_25.QuerySendEnabledResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySendEnabledResponse: Could not create message: ' + e.message);
            }
        },
        querySpendableBalancesResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse", value: query_26.QuerySpendableBalancesResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QuerySpendableBalancesResponse: Could not create message: ' + e.message);
            }
        },
        queryDenomMetadataResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse", value: query_27.QueryDenomMetadataResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDenomMetadataResponse: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosBankV1Beta1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
