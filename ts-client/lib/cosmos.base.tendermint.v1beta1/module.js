"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.GetSyncingRequest = exports.GetLatestValidatorSetResponse = exports.GetNodeInfoRequest = exports.GetSyncingResponse = exports.GetBlockByHeightResponse = exports.Header = exports.Module = exports.GetNodeInfoResponse = exports.GetValidatorSetByHeightResponse = exports.Block = exports.GetValidatorSetByHeightRequest = exports.ProofOps = exports.ABCIQueryRequest = exports.GetBlockByHeightRequest = exports.GetLatestValidatorSetRequest = exports.ProofOp = exports.ABCIQueryResponse = exports.VersionInfo = exports.Validator = exports.GetLatestBlockResponse = exports.GetLatestBlockRequest = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const query_1 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetLatestBlockRequest", { enumerable: true, get: function () { return query_1.GetLatestBlockRequest; } });
const query_2 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetLatestBlockResponse", { enumerable: true, get: function () { return query_2.GetLatestBlockResponse; } });
const query_3 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "Validator", { enumerable: true, get: function () { return query_3.Validator; } });
const query_4 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "VersionInfo", { enumerable: true, get: function () { return query_4.VersionInfo; } });
const query_5 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "ABCIQueryResponse", { enumerable: true, get: function () { return query_5.ABCIQueryResponse; } });
const query_6 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "ProofOp", { enumerable: true, get: function () { return query_6.ProofOp; } });
const query_7 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetLatestValidatorSetRequest", { enumerable: true, get: function () { return query_7.GetLatestValidatorSetRequest; } });
const query_8 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetBlockByHeightRequest", { enumerable: true, get: function () { return query_8.GetBlockByHeightRequest; } });
const query_9 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "ABCIQueryRequest", { enumerable: true, get: function () { return query_9.ABCIQueryRequest; } });
const query_10 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "ProofOps", { enumerable: true, get: function () { return query_10.ProofOps; } });
const query_11 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetValidatorSetByHeightRequest", { enumerable: true, get: function () { return query_11.GetValidatorSetByHeightRequest; } });
const types_1 = require("./types/cosmos/base/tendermint/v1beta1/types");
Object.defineProperty(exports, "Block", { enumerable: true, get: function () { return types_1.Block; } });
const query_12 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetValidatorSetByHeightResponse", { enumerable: true, get: function () { return query_12.GetValidatorSetByHeightResponse; } });
const query_13 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetNodeInfoResponse", { enumerable: true, get: function () { return query_13.GetNodeInfoResponse; } });
const query_14 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "Module", { enumerable: true, get: function () { return query_14.Module; } });
const types_2 = require("./types/cosmos/base/tendermint/v1beta1/types");
Object.defineProperty(exports, "Header", { enumerable: true, get: function () { return types_2.Header; } });
const query_15 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetBlockByHeightResponse", { enumerable: true, get: function () { return query_15.GetBlockByHeightResponse; } });
const query_16 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetSyncingResponse", { enumerable: true, get: function () { return query_16.GetSyncingResponse; } });
const query_17 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetNodeInfoRequest", { enumerable: true, get: function () { return query_17.GetNodeInfoRequest; } });
const query_18 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetLatestValidatorSetResponse", { enumerable: true, get: function () { return query_18.GetLatestValidatorSetResponse; } });
const query_19 = require("./types/cosmos/base/tendermint/v1beta1/query");
Object.defineProperty(exports, "GetSyncingRequest", { enumerable: true, get: function () { return query_19.GetSyncingRequest; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendGetLatestBlockRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetLatestBlockRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getLatestBlockRequest({ value: query_1.GetLatestBlockRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetLatestBlockRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetLatestBlockResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetLatestBlockResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getLatestBlockResponse({ value: query_2.GetLatestBlockResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetLatestBlockResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidator({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidator: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.validator({ value: query_3.Validator.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidator: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendVersionInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendVersionInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.versionInfo({ value: query_4.VersionInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendVersionInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendABCIQueryResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendABCIQueryResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.abciqueryResponse({ value: query_5.ABCIQueryResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendABCIQueryResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendProofOp({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendProofOp: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.proofOp({ value: query_6.ProofOp.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendProofOp: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetLatestValidatorSetRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetLatestValidatorSetRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getLatestValidatorSetRequest({ value: query_7.GetLatestValidatorSetRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetLatestValidatorSetRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetBlockByHeightRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetBlockByHeightRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getBlockByHeightRequest({ value: query_8.GetBlockByHeightRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetBlockByHeightRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendABCIQueryRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendABCIQueryRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.abciqueryRequest({ value: query_9.ABCIQueryRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendABCIQueryRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendProofOps({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendProofOps: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.proofOps({ value: query_10.ProofOps.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendProofOps: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetValidatorSetByHeightRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetValidatorSetByHeightRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getValidatorSetByHeightRequest({ value: query_11.GetValidatorSetByHeightRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetValidatorSetByHeightRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBlock({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBlock: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.block({ value: types_1.Block.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBlock: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetValidatorSetByHeightResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetValidatorSetByHeightResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getValidatorSetByHeightResponse({ value: query_12.GetValidatorSetByHeightResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetValidatorSetByHeightResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetNodeInfoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetNodeInfoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getNodeInfoResponse({ value: query_13.GetNodeInfoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetNodeInfoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModule({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModule: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.module({ value: query_14.Module.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModule: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendHeader({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendHeader: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.header({ value: types_2.Header.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendHeader: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetBlockByHeightResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetBlockByHeightResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getBlockByHeightResponse({ value: query_15.GetBlockByHeightResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetBlockByHeightResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetSyncingResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetSyncingResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getSyncingResponse({ value: query_16.GetSyncingResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetSyncingResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetNodeInfoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetNodeInfoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getNodeInfoRequest({ value: query_17.GetNodeInfoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetNodeInfoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetLatestValidatorSetResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetLatestValidatorSetResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getLatestValidatorSetResponse({ value: query_18.GetLatestValidatorSetResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetLatestValidatorSetResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGetSyncingRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGetSyncingRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.getSyncingRequest({ value: query_19.GetSyncingRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGetSyncingRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        getLatestBlockRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetLatestBlockRequest", value: query_1.GetLatestBlockRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetLatestBlockRequest: Could not create message: ' + e.message);
            }
        },
        getLatestBlockResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetLatestBlockResponse", value: query_2.GetLatestBlockResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetLatestBlockResponse: Could not create message: ' + e.message);
            }
        },
        validator({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.Validator", value: query_3.Validator.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Validator: Could not create message: ' + e.message);
            }
        },
        versionInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.VersionInfo", value: query_4.VersionInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:VersionInfo: Could not create message: ' + e.message);
            }
        },
        abciqueryResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.ABCIQueryResponse", value: query_5.ABCIQueryResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ABCIQueryResponse: Could not create message: ' + e.message);
            }
        },
        proofOp({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.ProofOp", value: query_6.ProofOp.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ProofOp: Could not create message: ' + e.message);
            }
        },
        getLatestValidatorSetRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetLatestValidatorSetRequest", value: query_7.GetLatestValidatorSetRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetLatestValidatorSetRequest: Could not create message: ' + e.message);
            }
        },
        getBlockByHeightRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetBlockByHeightRequest", value: query_8.GetBlockByHeightRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetBlockByHeightRequest: Could not create message: ' + e.message);
            }
        },
        abciqueryRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.ABCIQueryRequest", value: query_9.ABCIQueryRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ABCIQueryRequest: Could not create message: ' + e.message);
            }
        },
        proofOps({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.ProofOps", value: query_10.ProofOps.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ProofOps: Could not create message: ' + e.message);
            }
        },
        getValidatorSetByHeightRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightRequest", value: query_11.GetValidatorSetByHeightRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetValidatorSetByHeightRequest: Could not create message: ' + e.message);
            }
        },
        block({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.Block", value: types_1.Block.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Block: Could not create message: ' + e.message);
            }
        },
        getValidatorSetByHeightResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse", value: query_12.GetValidatorSetByHeightResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetValidatorSetByHeightResponse: Could not create message: ' + e.message);
            }
        },
        getNodeInfoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetNodeInfoResponse", value: query_13.GetNodeInfoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetNodeInfoResponse: Could not create message: ' + e.message);
            }
        },
        module({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.Module", value: query_14.Module.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Module: Could not create message: ' + e.message);
            }
        },
        header({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.Header", value: types_2.Header.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Header: Could not create message: ' + e.message);
            }
        },
        getBlockByHeightResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse", value: query_15.GetBlockByHeightResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetBlockByHeightResponse: Could not create message: ' + e.message);
            }
        },
        getSyncingResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetSyncingResponse", value: query_16.GetSyncingResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetSyncingResponse: Could not create message: ' + e.message);
            }
        },
        getNodeInfoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetNodeInfoRequest", value: query_17.GetNodeInfoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetNodeInfoRequest: Could not create message: ' + e.message);
            }
        },
        getLatestValidatorSetResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse", value: query_18.GetLatestValidatorSetResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetLatestValidatorSetResponse: Could not create message: ' + e.message);
            }
        },
        getSyncingRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.base.tendermint.v1beta1.GetSyncingRequest", value: query_19.GetSyncingRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GetSyncingRequest: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosBaseTendermintV1Beta1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
