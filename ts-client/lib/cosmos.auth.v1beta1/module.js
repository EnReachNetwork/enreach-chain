"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.QueryAccountInfoResponse = exports.QueryAccountsResponse = exports.GenesisState = exports.QueryAccountAddressByIDRequest = exports.QueryModuleAccountsRequest = exports.BaseAccount = exports.AddressBytesToStringRequest = exports.QueryAccountRequest = exports.QueryAccountInfoRequest = exports.Bech32PrefixResponse = exports.QueryParamsResponse = exports.ModuleAccount = exports.MsgUpdateParamsResponse = exports.AddressBytesToStringResponse = exports.Bech32PrefixRequest = exports.MsgUpdateParams = exports.QueryModuleAccountsResponse = exports.ModuleCredential = exports.QueryAccountResponse = exports.QueryAccountAddressByIDResponse = exports.AddressStringToBytesResponse = exports.QueryModuleAccountByNameResponse = exports.QueryModuleAccountByNameRequest = exports.Params = exports.AddressStringToBytesRequest = exports.QueryParamsRequest = exports.QueryAccountsRequest = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const query_1 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountsRequest", { enumerable: true, get: function () { return query_1.QueryAccountsRequest; } });
const query_2 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryParamsRequest", { enumerable: true, get: function () { return query_2.QueryParamsRequest; } });
const query_3 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "AddressStringToBytesRequest", { enumerable: true, get: function () { return query_3.AddressStringToBytesRequest; } });
const auth_1 = require("./types/cosmos/auth/v1beta1/auth");
Object.defineProperty(exports, "Params", { enumerable: true, get: function () { return auth_1.Params; } });
const query_4 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryModuleAccountByNameRequest", { enumerable: true, get: function () { return query_4.QueryModuleAccountByNameRequest; } });
const query_5 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryModuleAccountByNameResponse", { enumerable: true, get: function () { return query_5.QueryModuleAccountByNameResponse; } });
const query_6 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "AddressStringToBytesResponse", { enumerable: true, get: function () { return query_6.AddressStringToBytesResponse; } });
const query_7 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountAddressByIDResponse", { enumerable: true, get: function () { return query_7.QueryAccountAddressByIDResponse; } });
const query_8 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountResponse", { enumerable: true, get: function () { return query_8.QueryAccountResponse; } });
const auth_2 = require("./types/cosmos/auth/v1beta1/auth");
Object.defineProperty(exports, "ModuleCredential", { enumerable: true, get: function () { return auth_2.ModuleCredential; } });
const query_9 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryModuleAccountsResponse", { enumerable: true, get: function () { return query_9.QueryModuleAccountsResponse; } });
const tx_1 = require("./types/cosmos/auth/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParams", { enumerable: true, get: function () { return tx_1.MsgUpdateParams; } });
const query_10 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "Bech32PrefixRequest", { enumerable: true, get: function () { return query_10.Bech32PrefixRequest; } });
const query_11 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "AddressBytesToStringResponse", { enumerable: true, get: function () { return query_11.AddressBytesToStringResponse; } });
const tx_2 = require("./types/cosmos/auth/v1beta1/tx");
Object.defineProperty(exports, "MsgUpdateParamsResponse", { enumerable: true, get: function () { return tx_2.MsgUpdateParamsResponse; } });
const auth_3 = require("./types/cosmos/auth/v1beta1/auth");
Object.defineProperty(exports, "ModuleAccount", { enumerable: true, get: function () { return auth_3.ModuleAccount; } });
const query_12 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryParamsResponse", { enumerable: true, get: function () { return query_12.QueryParamsResponse; } });
const query_13 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "Bech32PrefixResponse", { enumerable: true, get: function () { return query_13.Bech32PrefixResponse; } });
const query_14 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountInfoRequest", { enumerable: true, get: function () { return query_14.QueryAccountInfoRequest; } });
const query_15 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountRequest", { enumerable: true, get: function () { return query_15.QueryAccountRequest; } });
const query_16 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "AddressBytesToStringRequest", { enumerable: true, get: function () { return query_16.AddressBytesToStringRequest; } });
const auth_4 = require("./types/cosmos/auth/v1beta1/auth");
Object.defineProperty(exports, "BaseAccount", { enumerable: true, get: function () { return auth_4.BaseAccount; } });
const query_17 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryModuleAccountsRequest", { enumerable: true, get: function () { return query_17.QueryModuleAccountsRequest; } });
const query_18 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountAddressByIDRequest", { enumerable: true, get: function () { return query_18.QueryAccountAddressByIDRequest; } });
const genesis_1 = require("./types/cosmos/auth/v1beta1/genesis");
Object.defineProperty(exports, "GenesisState", { enumerable: true, get: function () { return genesis_1.GenesisState; } });
const query_19 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountsResponse", { enumerable: true, get: function () { return query_19.QueryAccountsResponse; } });
const query_20 = require("./types/cosmos/auth/v1beta1/query");
Object.defineProperty(exports, "QueryAccountInfoResponse", { enumerable: true, get: function () { return query_20.QueryAccountInfoResponse; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendQueryAccountsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountsRequest({ value: query_1.QueryAccountsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsRequest({ value: query_2.QueryParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAddressStringToBytesRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAddressStringToBytesRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.addressStringToBytesRequest({ value: query_3.AddressStringToBytesRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAddressStringToBytesRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.params({ value: auth_1.Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryModuleAccountByNameRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryModuleAccountByNameRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryModuleAccountByNameRequest({ value: query_4.QueryModuleAccountByNameRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryModuleAccountByNameRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryModuleAccountByNameResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryModuleAccountByNameResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryModuleAccountByNameResponse({ value: query_5.QueryModuleAccountByNameResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryModuleAccountByNameResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAddressStringToBytesResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAddressStringToBytesResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.addressStringToBytesResponse({ value: query_6.AddressStringToBytesResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAddressStringToBytesResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountAddressByIDResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountAddressByIDResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountAddressByIdresponse({ value: query_7.QueryAccountAddressByIDResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountAddressByIDResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountResponse({ value: query_8.QueryAccountResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModuleCredential({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModuleCredential: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.moduleCredential({ value: auth_2.ModuleCredential.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModuleCredential: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryModuleAccountsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryModuleAccountsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryModuleAccountsResponse({ value: query_9.QueryModuleAccountsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryModuleAccountsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParams({ value: tx_1.MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBech32PrefixRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBech32PrefixRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.bech32PrefixRequest({ value: query_10.Bech32PrefixRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBech32PrefixRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAddressBytesToStringResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAddressBytesToStringResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.addressBytesToStringResponse({ value: query_11.AddressBytesToStringResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAddressBytesToStringResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.msgUpdateParamsResponse({ value: tx_2.MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendModuleAccount({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendModuleAccount: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.moduleAccount({ value: auth_3.ModuleAccount.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendModuleAccount: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryParamsResponse({ value: query_12.QueryParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBech32PrefixResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBech32PrefixResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.bech32PrefixResponse({ value: query_13.Bech32PrefixResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBech32PrefixResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountInfoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountInfoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountInfoRequest({ value: query_14.QueryAccountInfoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountInfoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountRequest({ value: query_15.QueryAccountRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendAddressBytesToStringRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendAddressBytesToStringRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.addressBytesToStringRequest({ value: query_16.AddressBytesToStringRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendAddressBytesToStringRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBaseAccount({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBaseAccount: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.baseAccount({ value: auth_4.BaseAccount.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBaseAccount: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryModuleAccountsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryModuleAccountsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryModuleAccountsRequest({ value: query_17.QueryModuleAccountsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryModuleAccountsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountAddressByIDRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountAddressByIDRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountAddressByIdrequest({ value: query_18.QueryAccountAddressByIDRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountAddressByIDRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.genesisState({ value: genesis_1.GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountsResponse({ value: query_19.QueryAccountsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAccountInfoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAccountInfoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry });
                let msg = this.queryAccountInfoResponse({ value: query_20.QueryAccountInfoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAccountInfoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        queryAccountsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest", value: query_1.QueryAccountsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountsRequest: Could not create message: ' + e.message);
            }
        },
        queryParamsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest", value: query_2.QueryParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message);
            }
        },
        addressStringToBytesRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest", value: query_3.AddressStringToBytesRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AddressStringToBytesRequest: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.Params", value: auth_1.Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        queryModuleAccountByNameRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest", value: query_4.QueryModuleAccountByNameRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryModuleAccountByNameRequest: Could not create message: ' + e.message);
            }
        },
        queryModuleAccountByNameResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse", value: query_5.QueryModuleAccountByNameResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryModuleAccountByNameResponse: Could not create message: ' + e.message);
            }
        },
        addressStringToBytesResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse", value: query_6.AddressStringToBytesResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AddressStringToBytesResponse: Could not create message: ' + e.message);
            }
        },
        queryAccountAddressByIdresponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse", value: query_7.QueryAccountAddressByIDResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountAddressByIDResponse: Could not create message: ' + e.message);
            }
        },
        queryAccountResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse", value: query_8.QueryAccountResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountResponse: Could not create message: ' + e.message);
            }
        },
        moduleCredential({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.ModuleCredential", value: auth_2.ModuleCredential.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ModuleCredential: Could not create message: ' + e.message);
            }
        },
        queryModuleAccountsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse", value: query_9.QueryModuleAccountsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryModuleAccountsResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParams", value: tx_1.MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        bech32PrefixRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest", value: query_10.Bech32PrefixRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Bech32PrefixRequest: Could not create message: ' + e.message);
            }
        },
        addressBytesToStringResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse", value: query_11.AddressBytesToStringResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AddressBytesToStringResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.MsgUpdateParamsResponse", value: tx_2.MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        moduleAccount({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.ModuleAccount", value: auth_3.ModuleAccount.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ModuleAccount: Could not create message: ' + e.message);
            }
        },
        queryParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse", value: query_12.QueryParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message);
            }
        },
        bech32PrefixResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse", value: query_13.Bech32PrefixResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Bech32PrefixResponse: Could not create message: ' + e.message);
            }
        },
        queryAccountInfoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest", value: query_14.QueryAccountInfoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountInfoRequest: Could not create message: ' + e.message);
            }
        },
        queryAccountRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest", value: query_15.QueryAccountRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountRequest: Could not create message: ' + e.message);
            }
        },
        addressBytesToStringRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest", value: query_16.AddressBytesToStringRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:AddressBytesToStringRequest: Could not create message: ' + e.message);
            }
        },
        baseAccount({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.BaseAccount", value: auth_4.BaseAccount.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BaseAccount: Could not create message: ' + e.message);
            }
        },
        queryModuleAccountsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest", value: query_17.QueryModuleAccountsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryModuleAccountsRequest: Could not create message: ' + e.message);
            }
        },
        queryAccountAddressByIdrequest({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest", value: query_18.QueryAccountAddressByIDRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountAddressByIDRequest: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.GenesisState", value: genesis_1.GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        queryAccountsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse", value: query_19.QueryAccountsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountsResponse: Could not create message: ' + e.message);
            }
        },
        queryAccountInfoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse", value: query_20.QueryAccountInfoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAccountInfoResponse: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosAuthV1Beta1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = IgntModule;
